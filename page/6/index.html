

<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8"/>
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="renderer" content="webkit">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-status-bar-style" content="black">
	<meta name="description" content="但行好事 莫问前程">

	
		
			<link rel="stylesheet" href="/bower_components/fancybox/source/jquery.fancybox.css">
		
		<link rel="stylesheet" href="/bower_components/font-awesome/css/font-awesome.min.css">
		<link rel="stylesheet" href="/css/style.css">
	

	<title>但行好事 莫问前程 - 明羽</title>
<meta name="generator" content="Hexo 4.2.1"></head>
<body>
<header id="header">
	<div class="center">
		<div class="wrap">
			<div id="site">
				<h1>
					<a href="/">但行好事 莫问前程</a>
					
						<a class="github" href="https://github.com/dnxbf321" target="_blank" rel="noopener">
	  					<svg aria-hidden="true" class="octicon octicon-mark-github" height="28" role="img" version="1.1" viewBox="0 0 16 16" width="28"><path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59 0.4 0.07 0.55-0.17 0.55-0.38 0-0.19-0.01-0.82-0.01-1.49-2.01 0.37-2.53-0.49-2.69-0.94-0.09-0.23-0.48-0.94-0.82-1.13-0.28-0.15-0.68-0.52-0.01-0.53 0.63-0.01 1.08 0.58 1.23 0.82 0.72 1.21 1.87 0.87 2.33 0.66 0.07-0.52 0.28-0.87 0.51-1.07-1.78-0.2-3.64-0.89-3.64-3.95 0-0.87 0.31-1.59 0.82-2.15-0.08-0.2-0.36-1.02 0.08-2.12 0 0 0.67-0.21 2.2 0.82 0.64-0.18 1.32-0.27 2-0.27 0.68 0 1.36 0.09 2 0.27 1.53-1.04 2.2-0.82 2.2-0.82 0.44 1.1 0.16 1.92 0.08 2.12 0.51 0.56 0.82 1.27 0.82 2.15 0 3.07-1.87 3.75-3.65 3.95 0.29 0.25 0.54 0.73 0.54 1.48 0 1.07-0.01 1.93-0.01 2.2 0 0.21 0.15 0.46 0.55 0.38C13.71 14.53 16 11.53 16 8 16 3.58 12.42 0 8 0z"></path></svg>
						</a>
					
				</h1>
				
					<h2>
						<a href="/">明羽</a>
					</h2>
				
			</div>
			<nav id="menu">
				<ul>
					
						<li><a href="/">首页</a></li>
					
						<li><a href="/archives/">归档</a></li>
					
				</ul>
			</nav>
		</div>
	</div>
</header>

<div id="content">
	<div class="center">
		<div class="main-col">
			

	
		
		<article class="post">
	<div class="post-content">
		<header>
			
				<div class="meta">
					<div class="icon">
						
							<i class="fa fa-file"></i>
						
					</div>
					<time datetime="2019-02-28T08:15:27.000Z">2019-02-28</time>
				</div>
			
			
	
		<h1 class="title" data-role="articleTitle"><a href="/design/">设计模式详解</a></h1>
	

		</header>
		<div class="entry">
			
				<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><blockquote>
<p>学习设计模式不是一蹴而就的事情，需要长时间的积累，在平时写代码的时候多思考，学习设计模式的时候也不要死记硬背，要了解每个设计模式都解决了那些问题，另外就是最好要记住每种设计模式的类图，这样对于实操写代码的时候很有帮助    </p>
</blockquote>
<p>设计模式是软件设计中的最佳实践，是由前人的知识和经验总结而来，是针对不同特定场景问题的解决方案，通过学习设计模式，可以让我们知道在什么情况下应该使用什么设计模式，也可以增加我们对于软件设计的理解，设计出更稳定，扩展性更好的系统</p>
<p>设计模式总共包括6大设计原则和23种设计模式，23种设计模式又分为创建型模式，结构型模式，行为型模式三种，每种模式解决的问题也不相同，创建型设计模式主要关注与如何创建对象；结构型设计模式主要关注于类和对象之间的关系；而行为型设计模式关注于对象之间的通信；</p>
<h2 id="23种设计模式"><a href="#23种设计模式" class="headerlink" title="23种设计模式"></a>23种设计模式</h2><p>每种设计模式都以定义，类图，角色，优缺点，示例的方式进行讲解</p>
<p><strong>源码地址：<a href="https://github.com/mingyuHub/design-patterns" target="_blank" rel="noopener">https://github.com/mingyuHub/design-patterns</a></strong></p>
<p>各模式之间关联：</p>
<p><img src="/design/the-relationship-between-design-patterns.jpg" alt></p>
<h3 id="创建型设计模式"><a href="#创建型设计模式" class="headerlink" title="创建型设计模式"></a>创建型设计模式</h3><p><strong>关注于如何创建对象</strong></p>
<h5 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a><a href="https://chenmingyu.top/design-singleton/">单例模式</a></h5><p>保证在程序运行期间一个类只有一个实例，并提供一个全局访问点</p>
<h5 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a><a href="https://chenmingyu.top/design-factory-method/">工厂模式</a></h5><p>用工厂方法代替new操作，让子类去决定实例化哪个类，工厂方法将一个类的实例化延迟到子类</p>
<h5 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a><a href="https://chenmingyu.top/design-abstract-factory/">抽象工厂</a></h5><p>抽象工厂模式属于创建型模式，是对工厂方法模式的扩展，抽象工厂比工厂模式更为抽象，工厂方法模式针对产品等级结构，而抽象工厂针对产品族</p>
<h5 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a><a href="https://chenmingyu.top/design-builder/">建造者模式</a></h5><p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示</p>
<h5 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a><a href="https://chenmingyu.top/design-phototype/">原型模式</a></h5><p>通过克隆一个已经存在的对象实例来返回新的实例，而不是通过new去创建对象</p>
<h3 id="结构型设计模式"><a href="#结构型设计模式" class="headerlink" title="结构型设计模式"></a>结构型设计模式</h3><p><strong>关注于类和对象之间的关系</strong></p>
<h5 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a><a href="https://chenmingyu.top/design-adapter/">适配器模式</a></h5><p>组合两个不相干类，在两个不兼容的接口之间提供一个混合接口，使其兼容适配</p>
<h5 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a><a href="https://chenmingyu.top/design-bridge/">桥接模式</a></h5><p>将抽象部分与它的实现部分分离，使它们都可以独立地变化。桥接模式将系统各维度抽象出来，各维度独立变化，之后可通过聚合，将各维度组合起来，减少它们之间耦合</p>
<h5 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a><a href="https://chenmingyu.top/design-composite/">组合模式</a></h5><p>用来描述部分与整体的关系，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，所以组合模式的使用场景就是出现树形结构的地方。</p>
<h5 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a><a href="https://chenmingyu.top/design-decorator/">装饰器模式</a></h5><p>装饰器模式可以为一个现有的类增加新功能，又不改变其结构，要求装饰类和被装饰类实现同一个接口，装饰类持有被装饰类的实例</p>
<h5 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a><a href="https://chenmingyu.top/design-facade/">外观模式</a></h5><p>外观模式是为了解决类与类之家的责任关系和依赖关系的，通过提供一个Facade类来隐藏这些复杂的类之间关系的调用，并提供一个接口，供外部调用，利用这种方式进行类之间的解耦</p>
<h5 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a><a href="https://chenmingyu.top/design-proxy/">代理模式</a></h5><p>代理模式就是在操作原对象的时候，多出来一个代理类，用来对原对象的访问进行控制和替代原对象进行一些操作</p>
<h5 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a><a href="https://chenmingyu.top/design-flyweight/">享元模式</a></h5><p>运用共享技术有效地支持大量细粒度对象的复用，主要用来减少对象的创建，用来减少内存和提高性能，比较常见的连接池，缓冲池这类的池技术都是享元模式</p>
<h3 id="行为型设计模式"><a href="#行为型设计模式" class="headerlink" title="行为型设计模式"></a>行为型设计模式</h3><p><strong>关注于对象之间的通信</strong></p>
<h5 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a><a href="https://chenmingyu.top/design-template-method/">模板方法模式</a></h5><p>在父类（抽象类）中定义好算法的流程，提供抽象方法，针对不同的实现交由不同的子类去实现，通过这种方式将公共代码提取出来封装在父类中，然后父类去控制行为，子类负责实现</p>
<h5 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a><a href="https://chenmingyu.top/design-strategy/">策略模式</a></h5><p>在系统中提供一组策略，并将每个策略封装成类，使他们可以相互转换，具体策略的选择由客户端决定</p>
<h5 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a><a href="https://chenmingyu.top/design-observer/">观察者模式</a></h5><p>定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新</p>
<h5 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a><a href="https://chenmingyu.top/design-iterator/">迭代器模式</a></h5><p>迭代器模式就是为解决遍历元素而诞生的，它提供一种方法访问一个容器对象中各个元素，而又不需暴露该对象的内部细节</p>
<h5 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a><a href="https://chenmingyu.top/design-chain/">责任链模式</a></h5><p>使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止</p>
<h5 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a><a href="https://chenmingyu.top/design-command/">命令模式</a></h5><p>将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能，用来降低类之间解耦</p>
<h5 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a><a href="https://chenmingyu.top/design-memento/">备忘录模式</a></h5><p>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态，其实就是在某个时刻备份了对象的状态，在更改对象状态后，可以通过备份将对象还原成备份时刻的状态</p>
<h5 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a><a href="https://chenmingyu.top/design-state/">状态模式</a></h5><p>允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类，对象的行为依赖于它的状态（属性），并且可以根据它的状态改变而改变它的相关行为</p>
<h5 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a><a href="https://chenmingyu.top/design-visitor/">访问者模式</a></h5><p>封装一些作用于某种数据结构中的各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作，访问者模式就是将数据结构与数据操作相分离</p>
<h5 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a><a href="https://chenmingyu.top/design-mediator/">中介者模式</a></h5><p>用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互</p>
<h5 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a><a href="https://chenmingyu.top/design-interpreter/">解释器模式</a></h5><p>给定一门语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子</p>
<h3 id="六大原则"><a href="#六大原则" class="headerlink" title="六大原则"></a>六大原则</h3><h4 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h4><p>单一职责要求的是类和接口职责单一，不能存在多于一个导致类变更的原因</p>
<h4 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h4><p>对扩展开放，对修改关闭，在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果</p>
<h4 id="里氏代换原则"><a href="#里氏代换原则" class="headerlink" title="里氏代换原则"></a>里氏代换原则</h4><p>里氏代换原则是面向对象设计的基本原则之一，氏代换原则中说，任何父类可以出现的地方，子类一定可以出现。子类对父类的方法尽量不要重写和重载。因为父类代表了定义好的结构，通过这个规范的接口与外界交互，子类不应该随便破坏它</p>
<h4 id="依赖倒转原则"><a href="#依赖倒转原则" class="headerlink" title="依赖倒转原则"></a>依赖倒转原则</h4><p>这个是开闭原则的基础，具体内容：面向接口编程，依赖于抽象而不依赖于具体。写代码时用到具体类时，不与具体类交互，而与具体类的上层接口交互</p>
<h4 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h4><p>这个的意思每个接口的职责应该是单一的，接口中不应该存在子类用不到的方法，如若不然，就需要将接口拆分为多个接口</p>
<h4 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h4><p>迪米特法则又叫最少知道原则，一个类对自己依赖的类知道的越少越好。也就是说无论被依赖的类多么复杂，都应该将逻辑封装在方法的内部，通过public方法提供给外部。这样当被依赖的类变化时，才能最小的影响该类</p>

			
		</div>
		<footer class="clearfix">
			
				
				
					<div class="disqus-comment">
						<i class="fa fa-comment"></i><a href="https://chenmingyu.top/design/#disqus_thread" class="comment-link"> 评论</a>
					</div>
				
			
			
	<div class="categories">
		<i class="fa fa-folder"></i>
		
			<a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
		
	</div>

			
	<div class="tags">
		<i class="fa fa-tags"></i>
		
			<a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">#设计模式</a>
		
	</div>

		</footer>
	</div>
</article>
	
		
		<article class="post">
	<div class="post-content">
		<header>
			
				<div class="meta">
					<div class="icon">
						
							<i class="fa fa-file"></i>
						
					</div>
					<time datetime="2019-02-28T03:03:05.000Z">2019-02-28</time>
				</div>
			
			
	
		<h1 class="title" data-role="articleTitle"><a href="/design-phototype/">23种设计模式之原型模式</a></h1>
	

		</header>
		<div class="entry">
			
				<h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>原型模式属于创建型设计模式</p>
<p><strong>定义：</strong>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象</p>
<p>原型模式通过克隆一个已经存在的对象实例来返回新的实例，而不是通过new去创建对象，多用于创建复杂的或者耗时的实例，因为这种情况下，复制一个已经存在的实例使程序运行更高效；</p>
<p>java中复制对象是通过重写<code>clone()</code>实现的，原型类需要实现<code>Cloneable</code>接口，否则报<code>CloneNotSupportedException</code>异常</p>
<h3 id="模式类图"><a href="#模式类图" class="headerlink" title="模式类图"></a>模式类图</h3><p><img src="/design-phototype/uml.png" alt></p>
<p><strong>角色</strong></p>
<ol>
<li>抽象原型：Prototype，可以为接口或者抽象类，实现了<code>Cloneable</code>接口，重写了<code>clone()</code>方法，子类只需实现或集成即可拥有克隆功能</li>
<li>具体原型：PrototypeA，PrototypeB，实现/集成了Prototype接口的类，拥有克隆方法</li>
<li>工厂模式：原型模式常和工厂模式一起使用，通过 clone 的方法创建一个对象，然后由工厂方法提供给调用者</li>
</ol>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li>性能优良，比new一个对象性能好很多</li>
<li>不受对象构造函数的约束</li>
</ol>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p><strong>源码地址：<a href="https://github.com/mingyuHub/design-patterns" target="_blank" rel="noopener">https://github.com/mingyuHub/design-patterns</a></strong></p>
<p>以获取笔对象为例子，结合工厂模式讲解如何使用原型模式，涉及的类：<code>Pen</code>（抽象类），<code>Pencil</code>（铅笔），<code>CarbonPen</code>（碳素笔），<code>PenFactory</code>（工厂类）</p>
<h5 id="抽象原型"><a href="#抽象原型" class="headerlink" title="抽象原型"></a>抽象原型</h5><p>抽象类，实现了<code>Cloneable</code>接口，重写了<code>clone()</code>方法</p>
<pre><code class="java">/**
 * @author: chenmingyu
 * @date: 2019/2/28 09:54
 * @description: 抽象原型角色
 */
@Data
public abstract class Pen implements Cloneable{

    private String name;

    public Pen(String name) {
        this.name = name;
    }

    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}</code></pre>
<h5 id="具体原型"><a href="#具体原型" class="headerlink" title="具体原型"></a>具体原型</h5><p><code>Pencil</code>，继承<code>Pen</code></p>
<pre><code class="java">/**
 * @author: chenmingyu
 * @date: 2019/2/28 11:27
 * @description: 铅笔
 */
public class Pencil extends Pen{

    public Pencil(String name) {
        super(name);
    }
}</code></pre>
<p><code>CarbonPen</code>，继承了`Pen</p>
<pre><code class="java">/**
 * @author: chenmingyu
 * @date: 2019/2/28 11:29
 * @description: 碳素笔
 */
public class CarbonPen extends  Pen{

    public CarbonPen(String name) {
        super(name);
    }
}</code></pre>
<h5 id="工厂类"><a href="#工厂类" class="headerlink" title="工厂类"></a>工厂类</h5><p>简单工厂实现</p>
<pre><code class="java">/**
 * @author: chenmingyu
 * @date: 2019/2/28 11:32
 * @description: 笔生产工厂
 */
public class PenFactory {

    /**
     * 原型类容器
     */
    private static Map&lt;String, Pen&gt; penMap = new Hashtable&lt;&gt;();

    /**
     * 初始化
     */
    public static void init() {
        Pen carbonPen = new CarbonPen(&quot;碳素笔&quot;);
        penMap.put(CarbonPen.class.getName(),carbonPen);
        Pen pencil = new Pencil(&quot;铅笔&quot;);
        penMap.put(Pencil.class.getName(),pencil);
    }

    /**
     * 通过复制获取实例
     * @param className
     * @return
     * @throws CloneNotSupportedException
     */
    public static Pen getPen(Class className) throws CloneNotSupportedException{
        Pen cachedShape = penMap.get(className.getName());
        return (Pen) cachedShape.clone();
    }

}</code></pre>
<h5 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h5><pre><code class="java">public static void main(String[] args){
        PenFactory.init();
        IntStream.range(0,2).forEach(i-&gt;{
            try {
                System.out.println(PenFactory.getPen(CarbonPen.class).getClass());
                System.out.println(PenFactory.getPen(Pencil.class).getClass());
                System.out.println(&quot;  ... &quot;);
            }catch (CloneNotSupportedException e){
                e.printStackTrace();
            }
        });
    }</code></pre>
<p>输出</p>
<pre><code class="java">class com.example.design.prototype.CarbonPen
class com.example.design.prototype.Pencil
  ... 
class com.example.design.prototype.CarbonPen
class com.example.design.prototype.Pencil
  ... </code></pre>
<h3 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h3><p>浅拷贝：将一个对象复制后，基本类型会被重新创建，引用类型的对象会把引用拷贝过去，实际上还是指向的同一个对象</p>
<p>深拷贝：将一个对象复制后，基本类型和引用类型的对象都会被重新创建</p>
<h5 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h5><p>举个例子</p>
<pre><code class="java">/**
 * @author: chenmingyu
 * @date: 2019/2/28 14:53
 * @description: 克隆
 */
@Data
public class Clone implements Cloneable{

    private CloneA CloneA;

    public Clone() {
        this.CloneA = new CloneA();
    }

    @Override
    protected Clone clone() throws CloneNotSupportedException {
        return (Clone) super.clone();
    }

    class CloneA{
    }
}</code></pre>
<p>验证</p>
<pre><code class="java">public static void main(String[] args) throws CloneNotSupportedException{

    Clone clone = new Clone();
    Clone clone1 = clone.clone();
    System.out.println(clone == clone1);
    System.out.println(clone.getCloneA() == clone1.getCloneA());
}</code></pre>
<p>输出</p>
<pre><code class="java">false    
true</code></pre>
<p>所以clone()方法是执行的浅拷贝，这个需要在写代码的时候注意一下，浅拷贝是否可以满足需求</p>
<h5 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h5><p>深拷贝的实现方案主要有两种</p>
<ol>
<li>引用类型也使用clone()，进行clone的时候，对引用类型在调用一次clone()方法</li>
<li>使用序列化，将对象序列化后在反序列化回来，得到新的对象实例</li>
</ol>
<p>使用序列化实现以下</p>
<pre><code class="java">/**
 * @author: chenmingyu
 * @date: 2019/2/28 14:53
 * @description: 浅克隆
 */
@Data
public class Clone implements Cloneable ,Serializable {

    private CloneA CloneA;

    public Clone() {
        this.CloneA = new CloneA();
    }

    @Override
    protected Clone clone() throws CloneNotSupportedException {
        return (Clone) super.clone();
    }

    /**
     * 深拷贝
     * @return
     * @throws CloneNotSupportedException
     */
    protected Clone deepClone() throws CloneNotSupportedException {
        Clone clone = null;
        try{
            ByteArrayOutputStream baos=new ByteArrayOutputStream();
            ObjectOutputStream oos=new ObjectOutputStream(baos);
            oos.writeObject(this);
            oos.close();
            ByteArrayInputStream bais=new ByteArrayInputStream(baos.toByteArray());
            ObjectInputStream ois=new ObjectInputStream(bais);
            //生成新的对象实例
            clone=(Clone)ois.readObject();
            ois.close();
        }catch (Exception e){
            e.printStackTrace();
        }
        return clone;
    }

    class CloneA implements Serializable{
    }
}</code></pre>
<p>验证</p>
<pre><code class="java">public static void main(String[] args) throws CloneNotSupportedException{

    Clone clone = new Clone();
    Clone clone1 = clone.deepClone();
    System.out.println(clone == clone1);
    System.out.println(clone.getCloneA() == clone1.getCloneA());
}</code></pre>
<p>输出</p>
<pre><code class="java">false    
false</code></pre>
<p>在使用原型模式的时候一定要理解什么是浅拷贝和深拷贝，才可以放心的使用原型模式，并且一般都会和工厂模式一起使用</p>
<p><strong>推荐阅读：</strong><a href="https://chenmingyu.top/design/">23种设计模式详解</a></p>

			
		</div>
		<footer class="clearfix">
			
				
				
					<div class="disqus-comment">
						<i class="fa fa-comment"></i><a href="https://chenmingyu.top/design-phototype/#disqus_thread" class="comment-link"> 评论</a>
					</div>
				
			
			
	<div class="categories">
		<i class="fa fa-folder"></i>
		
			<a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
		
	</div>

			
	<div class="tags">
		<i class="fa fa-tags"></i>
		
			<a href="/tags/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/">#原型模式</a>
		
	</div>

		</footer>
	</div>
</article>
	
		
		<article class="post">
	<div class="post-content">
		<header>
			
				<div class="meta">
					<div class="icon">
						
							<i class="fa fa-file"></i>
						
					</div>
					<time datetime="2019-02-27T09:51:13.000Z">2019-02-27</time>
				</div>
			
			
	
		<h1 class="title" data-role="articleTitle"><a href="/design-abstract-factory/">23种设计模式之抽象工厂</a></h1>
	

		</header>
		<div class="entry">
			
				<h3 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h3><p>抽象工厂模式属于创建型模式</p>
<p><strong>定义：</strong>为创建一组相关或相互依赖的对象提供一个接口，而且无须指定它们的具体类</p>
<p>抽象工厂模式是对工厂方法模式的扩展，抽象工厂比工厂模式更为抽象，工厂方法模式针对产品等级结构，而抽象工厂针对产品族。</p>
<p>产品族与产品等级结构的概念：</p>
<p>​    产品族，是指位于不同产品等级结构中，功能相关联的产品组成的家族，比如游戏工厂生产射击类和塔防类两种产品，任天堂的射击类游戏和塔防类游戏为一个产品族，腾讯的射击类游戏和塔防类游戏为一个产品族</p>
<p>​    产品等级结构，一个产品族由多个产品等级结构组成，射击类游戏是一个产品等级结构，塔防类游戏也是一个产品等级结构</p>
<h4 id="模式类图"><a href="#模式类图" class="headerlink" title="模式类图"></a>模式类图</h4><p>以游戏为例，定义一个抽象工厂，生产射击和塔防两种游戏，有两个具体的生产工厂，任天堂和腾讯，两个工厂生产各自品牌的两类游戏产品</p>
<p><img src="/design-abstract-factory/uml.png" alt></p>
<p><strong>角色</strong>：</p>
<ol>
<li>抽象工厂：<code>GameFactory</code>，规定了生成射击类和塔防类两种游戏</li>
<li>具体工厂：<code>NintendoGameFactory</code>，<code>TencentGameFactory</code>，负责生产各自品牌的射击类和塔防类游戏</li>
<li>抽象产品：<code>Gameable</code>，<code>ShootGame</code>和<code>TowerDefenceGame</code>是抽象类，实现<code>Gameable</code></li>
<li>具体产品：<code>NintendoShootGame</code>，<code>NintendoTowerDefenceGame</code>，<code>TencentShootGame</code>，<code>TencentTowerDefenceGame</code></li>
</ol>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol>
<li>接口和实现分离，客户端面向接口编程，不用关心具体实现，从具体的产品实现中解耦</li>
<li>增加新的具体工厂和产品族方便，切换产品族方便</li>
</ol>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>不易增加新的产品，如果要增加新的产品需要抽象工厂和所有具体工厂</p>
<h4 id="模式代码实现"><a href="#模式代码实现" class="headerlink" title="模式代码实现"></a>模式代码实现</h4><p><strong>源码地址：<a href="https://github.com/mingyuHub/design-patterns" target="_blank" rel="noopener">https://github.com/mingyuHub/design-patterns</a></strong></p>
<h5 id="GameFactory"><a href="#GameFactory" class="headerlink" title="GameFactory"></a>GameFactory</h5><p>抽象工厂，规定了生产射击和塔防两类游戏</p>
<pre><code class="java">/**
 * @author: chenmingyu
 * @date: 2019/2/14 11:29
 * @description: 工厂类
 */
public interface GameFactory {

    /**
     * 创建射击游戏
     * @return
     */
    Gameable createShootGame();

    /**
     * 创建塔防游戏
     * @return
     */
    Gameable createTowerDefenceGame();
}</code></pre>
<h5 id="NintendoGameFactory"><a href="#NintendoGameFactory" class="headerlink" title="NintendoGameFactory"></a>NintendoGameFactory</h5><p>具体工厂，负责生产任天堂的射击类和塔防类游戏</p>
<pre><code class="java">/**
 * @author: chenmingyu
 * @date: 2019/2/14 18:20
 * @description: 任天堂游戏制造厂
 */
public class NintendoGameFactory implements GameFactory{

    @Override
    public Gameable createShootGame() {
        return new NintendoShootGame();
    }

    @Override
    public Gameable createTowerDefenceGame() {
        return new NintendoTowerDefenceGame();
    }
}</code></pre>
<h5 id="TencentGameFactory"><a href="#TencentGameFactory" class="headerlink" title="TencentGameFactory"></a>TencentGameFactory</h5><p>具体工厂，负责生产腾讯的射击类和塔防类游戏</p>
<pre><code class="java">/**
 * @author: chenmingyu
 * @date: 2019/2/14 18:20
 * @description: 腾讯游戏制造厂
 */
public class TencentGameFactory implements GameFactory {

    @Override
    public Gameable createShootGame() {
        return new TencentShootGame();
    }

    @Override
    public Gameable createTowerDefenceGame() {
        return new TencentTowerDefenceGame();
    }
}</code></pre>
<h5 id="Gameable"><a href="#Gameable" class="headerlink" title="Gameable"></a>Gameable</h5><p>抽象产品，所有游戏产品均实现该接口</p>
<pre><code class="java">/**
 * @author: chenmingyu
 * @date: 2019/2/14 11:19
 * @description: 游戏接口
 */
public interface Gameable {

    /**
     * 校验账户信息
     * @param nickName
     */
    void validateAccount(String nickName);


    /**
     * 游戏类型
     */
    void getGameType();
}</code></pre>
<h5 id="ShootGame和TowerDefenceGame"><a href="#ShootGame和TowerDefenceGame" class="headerlink" title="ShootGame和TowerDefenceGame"></a>ShootGame和TowerDefenceGame</h5><p>抽象类，实现Gameable接口</p>
<pre><code class="java">/**
 * @auther: chenmingyu
 * @date: 2019/2/14 11:26
 * @description: 射击类游戏
 */
public abstract class ShootGame implements Gameable{

    @Override
    public void validateAccount(String nickName) {
        System.out.println(&quot;射击游戏校验昵称：&quot;+nickName);
    }

}</code></pre>
<pre><code class="java">/**
 * @auther: chenmingyu
 * @date: 2019/2/14 11:28
 * @description: 塔防类游戏
 */
public abstract class TowerDefenceGame implements Gameable{

    @Override
    public void validateAccount(String nickName) {
        System.out.println(&quot;塔防游戏校验昵称：&quot;+nickName);
    }

}</code></pre>
<h5 id="具体产品"><a href="#具体产品" class="headerlink" title="具体产品"></a>具体产品</h5><p>共四款游戏产品：<code>NintendoShootGame</code>，<code>NintendoTowerDefenceGame</code>，<code>TencentShootGame</code>，<code>TencentTowerDefenceGame</code></p>
<pre><code class="java">/**
 * @author: chenmingyu
 * @date: 2019/2/15 16:57
 * @description: 任天堂射击游戏
 */
public class NintendoShootGame extends ShootGame{

    @Override
    public void getGameType() {
        System.out.println(&quot;任天堂射击游戏&quot;);
    }
}
</code></pre>
<pre><code class="java">/**
 * @author: chenmingyu
 * @date: 2019/2/15 17:18
 * @description: 任天堂塔防游戏
 */
public class NintendoTowerDefenceGame extends TowerDefenceGame{

    @Override
    public void getGameType() {
        System.out.println(&quot;任天堂塔防游戏&quot;);
    }
}</code></pre>
<pre><code class="java">/**
 * @author: chenmingyu
 * @date: 2019/2/15 16:55
 * @description: 腾讯射击游戏
 */
public class TencentShootGame extends ShootGame {

    @Override
    public void getGameType() {
        System.out.println(&quot;腾讯射击游戏&quot;);
    }
}</code></pre>
<pre><code class="java">/**
 * @author: chenmingyu
 * @date: 2019/2/15 17:17
 * @description: 腾讯塔防游戏
 */
public class TencentTowerDefenceGame extends TowerDefenceGame{

    @Override
    public void getGameType() {
        System.out.println(&quot;腾讯塔防游戏&quot;);
    }
}</code></pre>
<h5 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h5><pre><code class="java">public static void main(String[] args) throws Exception{

    NintendoGameFactory nintendoGameFactory = new NintendoGameFactory();
    nintendoGameFactory.createShootGame().getGameType();
    nintendoGameFactory.createTowerDefenceGame().getGameType();

    TencentGameFactory tencentGameFactory = new TencentGameFactory();
    tencentGameFactory.createShootGame().getGameType();
    tencentGameFactory.createTowerDefenceGame().getGameType();
}</code></pre>
<p>输出</p>
<pre><code class="java">任天堂射击游戏
任天堂塔防游戏
腾讯射击游戏
腾讯塔防游戏</code></pre>
<p><strong>参考：</strong></p>
<p>​    菜鸟教程：<a href="http://www.runoob.com/design-pattern/abstract-factory-pattern.html" target="_blank" rel="noopener">http://www.runoob.com/design-pattern/abstract-factory-pattern.html</a></p>
<p>​    图说设计模式：<a href="https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/abstract_factory.html" target="_blank" rel="noopener">https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/abstract_factory.html</a></p>
<p><strong>推荐阅读：</strong><a href="https://chenmingyu.top/design/">23种设计模式详解</a></p>

			
		</div>
		<footer class="clearfix">
			
				
				
					<div class="disqus-comment">
						<i class="fa fa-comment"></i><a href="https://chenmingyu.top/design-abstract-factory/#disqus_thread" class="comment-link"> 评论</a>
					</div>
				
			
			
	<div class="categories">
		<i class="fa fa-folder"></i>
		
			<a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
		
	</div>

			
	<div class="tags">
		<i class="fa fa-tags"></i>
		
			<a href="/tags/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/">#抽象工厂</a>
		
	</div>

		</footer>
	</div>
</article>
	
		
		<article class="post">
	<div class="post-content">
		<header>
			
				<div class="meta">
					<div class="icon">
						
							<i class="fa fa-file"></i>
						
					</div>
					<time datetime="2019-02-27T08:40:19.000Z">2019-02-27</time>
				</div>
			
			
	
		<h1 class="title" data-role="articleTitle"><a href="/design-iterator/">23中设计模式之迭代器模式</a></h1>
	

		</header>
		<div class="entry">
			
				<h3 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h3><p>迭代器模式属于行为型模式，描述的是类之间的关系</p>
<p><strong>定义：</strong> 它提供一种方法访问一个容器对象中各个元素，而又不需暴露该对象的内部细节</p>
<p>迭代器模式就是为解决遍历元素而诞生的，java而言，使用java提供的iterator就可以了，不用需要手动去写迭代器</p>
<h4 id="模式类图"><a href="#模式类图" class="headerlink" title="模式类图"></a>模式类图</h4><p><img src="/design-iterator/uml.png" alt></p>
<p><strong>角色：</strong></p>
<ol>
<li>抽象迭代器：<code>Iterator</code>，负责定义访问和遍历元素的接口</li>
<li>具体迭代器：<code>ConcreteIterator</code>，实现<code>Iterator</code>接口</li>
<li>抽象容器：<code>Aggregate</code>，负责提供创建具体迭代器角色的接口</li>
<li>具体容器： <code>ConcreteAggregate</code>，实现<code>Aggregate</code>接口</li>
</ol>
<h4 id="模式代码实现"><a href="#模式代码实现" class="headerlink" title="模式代码实现"></a>模式代码实现</h4><p><strong>源码地址：<a href="https://github.com/mingyuHub/design-patterns" target="_blank" rel="noopener">https://github.com/mingyuHub/design-patterns</a></strong></p>
<h5 id="抽象迭代器"><a href="#抽象迭代器" class="headerlink" title="抽象迭代器"></a>抽象迭代器</h5><p><code>Iterator</code>提供两个方法，返回下一个元素，是否还有下一个元素</p>
<pre><code class="java">/**
 * @author: chenmingyu
 * @date: 2019/3/17 19:07
 * @description: 抽象迭代器
 */
public interface Iterator {

    /**
     * 返回下一个元素
     * @return
     */
    public Object next();

    /**
     * 是否还有下一个元素
     * @return
     */
    public boolean hasNext();

}</code></pre>
<h5 id="具体迭代器实现"><a href="#具体迭代器实现" class="headerlink" title="具体迭代器实现"></a>具体迭代器实现</h5><p><code>cursor</code>为容器遍历元素时当前元素的容器下标</p>
<pre><code class="java">/**
 * @author: chenmingyu
 * @date: 2019/3/18 09:50
 * @description: 具体迭代器实现
 */
public class ConcreteIterator implements Iterator {

    /**
     * 当前位置
     */
    public int cursor = 0;

    /**
     * 容器
     */
    private List&lt;String&gt; list;

    public ConcreteIterator(List&lt;String&gt; list) {
        this.list = list;
    }

    @Override
    public Object next() {
        if(this.hasNext()){
            return this.list.get(this.cursor++);
        }
        return null;
    }

    @Override
    public boolean hasNext() {
        if(this.cursor == this.list.size()){
            return false;
        }else{
            return true;
        }
    }
}</code></pre>
<h5 id="抽象容器"><a href="#抽象容器" class="headerlink" title="抽象容器"></a>抽象容器</h5><p>提供三个方法，增加容器元素，删除容器元素，获取当前容器的迭代器</p>
<pre><code class="java">/**
 * @auther: chenmingyu
 * @date: 2019/3/18 09:51
 * @description: 抽象容器
 */
public interface Aggregate {

    /**
     * 增加元素
     * @param s
     */
    public void add(String s);

    /**
     * 删除元素
     * @param s
     */
    public void remove(String s);

    /**
     * 获取当前容器的迭代器
     * @return
     */
    public Iterator createIterator();
}</code></pre>
<h5 id="具体容器实现"><a href="#具体容器实现" class="headerlink" title="具体容器实现"></a>具体容器实现</h5><pre><code class="java">/**
 * @author: chenmingyu
 * @date: 2019/3/18 11:16
 * @description: 具体容器实现
 */
public class ConcreteAggregate implements  Aggregate {

    private List&lt;String&gt; list = new ArrayList&lt;&gt;();

    @Override
    public void add(String s) {
        list.add(s);
    }

    @Override
    public void remove(String s) {
        list.remove(s);
    }

    @Override
    public Iterator createIterator() {
        return new ConcreteIterator(list);
    }
}</code></pre>
<h5 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h5><pre><code class="java">public static void main(String[] args) {
    Aggregate aggregate = new ConcreteAggregate();
    aggregate.add(&quot;first title&quot;);
    aggregate.add(&quot;second title&quot;);
    aggregate.add(&quot;third title&quot;);
    Iterator iterator = aggregate.createIterator();
    while (iterator.hasNext()){
        System.out.println(iterator.next());
    }
}</code></pre>
<p>输出</p>
<pre><code class="java">first title
second title
third title</code></pre>
<p><strong>参考：</strong>设计模式之禅：<a href="https://www.kancloud.cn/sstd521/design/193578" target="_blank" rel="noopener">https://www.kancloud.cn/sstd521/design/193578</a></p>
<p><strong>推荐阅读：</strong><a href="https://chenmingyu.top/design/">23种设计模式详解</a></p>

			
		</div>
		<footer class="clearfix">
			
				
				
					<div class="disqus-comment">
						<i class="fa fa-comment"></i><a href="https://chenmingyu.top/design-iterator/#disqus_thread" class="comment-link"> 评论</a>
					</div>
				
			
			
	<div class="categories">
		<i class="fa fa-folder"></i>
		
			<a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
		
	</div>

			
	<div class="tags">
		<i class="fa fa-tags"></i>
		
			<a href="/tags/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/">#迭代器模式</a>
		
	</div>

		</footer>
	</div>
</article>
	
		
		<article class="post">
	<div class="post-content">
		<header>
			
				<div class="meta">
					<div class="icon">
						
							<i class="fa fa-file"></i>
						
					</div>
					<time datetime="2019-02-27T03:25:45.000Z">2019-02-27</time>
				</div>
			
			
	
		<h1 class="title" data-role="articleTitle"><a href="/springboot-thymeleaf/">spring Boot 2.x | 模板引擎 thymeleaf</a></h1>
	

		</header>
		<div class="entry">
			
				<blockquote>
<p>讲解springboot中使用模板thymeleaf引擎</p>
</blockquote>
<h4 id="什么是thymeleaf"><a href="#什么是thymeleaf" class="headerlink" title="什么是thymeleaf"></a>什么是thymeleaf</h4><p>thymeleaf是一款用于渲染XML/XHTML/HTML5内容的模板引擎。类似JSP，Velocity，FreeMaker等，它也可以轻易的与Spring MVC等Web框架进行集成作为Web应用的模板引擎。与其它模板引擎相比，Thymeleaf最大的特点是能够直接在浏览器中打开并正确显示模板页面，而不需要启动整个Web应用，比如<code>&lt;span th:text=&quot;${name}&quot;&gt;你好&lt;/span&gt;</code>这个标签，当直接打开静态页面的时候会显示你好，当使用动态数据之后会显示动态的数据，将<code>你好</code>覆盖</p>
<h5 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h5><p>在springboot中使用thymeleaf，项目依赖web模块和thymeleaf</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
<h5 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h5><p>springboot提供了<code>Thymeleaf</code>的默认配置，如果想要更改默认配置，需要在配置文件中修改相关属性</p>
<pre><code class="yml">spring:
  thymeleaf:
    mode: HTML5
    servlet:
      content-type: text/html
    cache: false #是否开启缓存
    encoding: UTF-8 #编码
    prefix: classpath:/templates/ #模板路径
    suffix: .html # 后缀</code></pre>
<h5 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h5><p>Spring Boot 官方推荐使用<code>Thymeleaf</code>模板引擎，默认的模板路径在src/main/resources/templates</p>
<p>新建一个test.html模板</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;测试&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h4&gt;&lt;span th:text=&quot;${name}&quot;&gt;你好&lt;/span&gt;&lt;/h4&gt;
我的博客地址是&lt;span th:text=&quot;${url}&quot;&gt;&lt;/span&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p>写个controller测试下</p>
<pre><code class="java">/**
 * @author: chenmingyu
 * @date: 2019/2/27 11:04
 * @description:
 */
@Controller
public class TestController {

    @GetMapping(&quot;test&quot;)
    public String test(Model model){

        model.addAttribute(&quot;name&quot;,&quot;叫我明羽&quot;);
        model.addAttribute(&quot;url&quot;,&quot;https://chenmingyu.top&quot;);
        return &quot;test&quot;;
    }
}</code></pre>
<p>访问 <a href="http://localhost:8080/test" target="_blank" rel="noopener">http://localhost:8080/test</a></p>
<p><img src="/springboot-thymeleaf/1.png" alt></p>
<p>想了解更多关于Thymeleaf的更多标签，语法可以访问<a href="https://www.thymeleaf.org/documentation.html" target="_blank" rel="noopener">Thymeleaf官网</a></p>

			
		</div>
		<footer class="clearfix">
			
				
				
					<div class="disqus-comment">
						<i class="fa fa-comment"></i><a href="https://chenmingyu.top/springboot-thymeleaf/#disqus_thread" class="comment-link"> 评论</a>
					</div>
				
			
			
	<div class="categories">
		<i class="fa fa-folder"></i>
		
			<a href="/categories/java/">java</a>
		
	</div>

			
	<div class="tags">
		<i class="fa fa-tags"></i>
		
			<a href="/tags/springboot/">#springboot</a>
		
			<a href="/tags/thymeleaf/">#thymeleaf</a>
		
	</div>

		</footer>
	</div>
</article>
	
		
		<article class="post">
	<div class="post-content">
		<header>
			
				<div class="meta">
					<div class="icon">
						
							<i class="fa fa-file"></i>
						
					</div>
					<time datetime="2019-02-26T08:00:43.000Z">2019-02-26</time>
				</div>
			
			
	
		<h1 class="title" data-role="articleTitle"><a href="/springboot-log/">spring Boot 2.x | 日志管理</a></h1>
	

		</header>
		<div class="entry">
			
				<p>springboot的web模块已经引入了日志模块，所以只需要在pom文件中引入web依赖就可以使用日志</p>
<h5 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h5><pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
<p>默认日志配置输出格式：时间 日志级别 进程id — [线程名] 类名  ： 输出的日志信息</p>
<pre><code class="java">2019-02-26 17:42:46.806  INFO 14072 --- [           main] c.my.log.SpringbootLogApplicationTests   : info</code></pre>
<p>springboot提供的日志级别为：<code>ERROR</code>, <code>WARN</code>, <code>INFO</code>, <code>DEBUG</code> ,<code>TRACE</code></p>
<p>默认<code>ERROR</code>、<code>WARN</code>和<code>INFO</code>级别的日志输出到控制台，</p>
<p>使用测试类测试一下</p>
<pre><code class="java">@RunWith(SpringRunner.class)
@SpringBootTest
public class SpringbootLogApplicationTests {

    Logger logger = LoggerFactory.getLogger(SpringbootLogApplicationTests.class);

    @Test
    public void test() {
        logger.error(&quot;日志级别：error&quot;);
        logger.warn(&quot;日志级别：warn&quot;);
        logger.info(&quot;日志级别：info&quot;);
        logger.debug(&quot;日志级别：debug&quot;);
        logger.trace(&quot;日志级别：trace&quot;);
    }
}</code></pre>
<p>日志输出</p>
<p><img src="/springboot-log/%E6%97%A5%E5%BF%97%E7%BA%A7%E5%88%AB.png" alt></p>
<h5 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h5><p>springboot提供的默认配置都可以通过配置文件进行修改</p>
<pre><code class="yml">logging:
  level:
    com.my.log: debug # com.my.log包下的日志级别为 info
  file: info.log #日志文件位置：可以是相对路径，也可以是绝对路径</code></pre>
<p>上述就是将 <code>com.my.log</code>包下的日志级别改为：<code>debug</code>，日志输出到info.log文件</p>
<p>在执行一下上面的测试类，看见输出已将日志级别改为<code>debug级别</code></p>
<p><img src="/springboot-log/E:%5Cmy%5Cmyblog%5Csource_posts%5Cspringboot-log%5Cdebug%E7%BA%A7%E5%88%AB.png" alt></p>
<p>并且在项目的根目录下生成<code>info.log</code>文件</p>
<p><img src="/springboot-log/E:%5Cmy%5Cmyblog%5Csource_posts%5Cspringboot-log%5Cinfo.log.png" alt></p>
<p>默认配置会在每个日志文件打到10M的时候进行截取，之后会生成新的日志文件</p>
<h5 id="自定义日志配置文件"><a href="#自定义日志配置文件" class="headerlink" title="自定义日志配置文件"></a>自定义日志配置文件</h5><p>一个项目中都会自定义配置文件，用来输出不同等级和不同业务的日志到不同的日志文件，这时候只需要将日志文件配置放到resources文件夹下，日志文件名定义为：logback-spring.xml就好</p>

			
		</div>
		<footer class="clearfix">
			
				
				
					<div class="disqus-comment">
						<i class="fa fa-comment"></i><a href="https://chenmingyu.top/springboot-log/#disqus_thread" class="comment-link"> 评论</a>
					</div>
				
			
			
	<div class="categories">
		<i class="fa fa-folder"></i>
		
			<a href="/categories/java/">java</a>
		
	</div>

			
	<div class="tags">
		<i class="fa fa-tags"></i>
		
			<a href="/tags/springboot/">#springboot</a>
		
			<a href="/tags/%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/">#日志管理</a>
		
	</div>

		</footer>
	</div>
</article>
	
		
		<article class="post">
	<div class="post-content">
		<header>
			
				<div class="meta">
					<div class="icon">
						
							<i class="fa fa-file"></i>
						
					</div>
					<time datetime="2019-02-24T05:48:22.000Z">2019-02-24</time>
				</div>
			
			
	
		<h1 class="title" data-role="articleTitle"><a href="/springboot-mail/">spring Boot 2.x | 发送文本邮件，HTML邮件，模板邮件</a></h1>
	

		</header>
		<div class="entry">
			
				<blockquote>
<p>springboot实现发送文本邮件，html邮件，模板邮件</p>
</blockquote>
<p>现在的网站，在注册用户时一般都会对注册用户发送一封邮件，用来验证注册用户的身份，或者用于一些报警提测，比如接口调用量，可用率报警等等</p>
<p>springboot中的<code>spring-boot-starter-mail</code>封装了发送邮件的接口，可以实现发送文本邮件，html邮件，发送模板邮件等等功能</p>
<h4 id="文本邮件，HTML邮件"><a href="#文本邮件，HTML邮件" class="headerlink" title="文本邮件，HTML邮件"></a>文本邮件，HTML邮件</h4><h5 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h5><p>pom文件中引入<code>spring-boot-starter-mail</code></p>
<pre><code class="xml">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
        &lt;artifactId&gt;lombok&lt;/artifactId&gt;
        &lt;optional&gt;true&lt;/optional&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</code></pre>
<h5 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h5><p>在配置文件中指定发送邮件的相关配置</p>
<pre><code class="yml">spring:
  mail:
    host: smtp.qq.com
    username: 你的邮箱
    password: 你的秘钥
    properties:
      mail:
        smtp:
          auth: true
    default-encoding: utf-8</code></pre>
<h5 id="定义发送邮件接口"><a href="#定义发送邮件接口" class="headerlink" title="定义发送邮件接口"></a>定义发送邮件接口</h5><p>EmailService接口提供两个接口：sendSimpleEmail，sendHtmlEmail</p>
<pre><code class="java">/**
 * @auther: chenmingyu
 * @date: 2019/2/24 13:00
 * @description: 邮件服务
 */
public interface EmailService {

    /**
     * 发送文本邮件
     * @param toMail 接收邮箱
     * @param subject 标题
     * @param text 文本
     * @return
     */
    boolean sendSimpleEmail(String toMail,String subject,String text);

    /**
     * 发送html邮件
     * @param toMail 接收邮箱
     * @param subject 标题
     * @param html html内容
     * @return
     */
    boolean sendHtmlEmail(String toMail,String subject,String html);
}</code></pre>
<h5 id="接口实现"><a href="#接口实现" class="headerlink" title="接口实现"></a>接口实现</h5><pre><code class="java">/**
 * @author: chenmingyu
 * @date: 2019/2/24 13:01
 * @description: 邮件服务
 */
@Service
public class EmailServiceImpl implements EmailService {

    @Resource
    private JavaMailSender mailSender;

    /**
     * 发送邮件邮箱
     */
    @Value(&quot;${spring.mail.username}&quot;)
    private String formMail;

    @Override
    public boolean sendSimpleEmail(String toMail,String subject,String text) {
        try {
            SimpleMailMessage simpleMailMessage = new SimpleMailMessage();
            simpleMailMessage.setFrom(formMail);
            simpleMailMessage.setTo(toMail);
            simpleMailMessage.setSubject(subject);
            simpleMailMessage.setText(text);
            mailSender.send(simpleMailMessage);
            System.out.println(&quot;发送文本邮件：toMail：&quot;+toMail);
            return true;
        }catch (Exception e){
            System.out.println(&quot;发送文本邮件异常：toMail：&quot;+toMail);
            e.printStackTrace();
        }
        return false;
    }

    @Override
    public boolean sendHtmlEmail(String toMail, String subject, String html) {
        try {
            MimeMessage mimeMessage = mailSender.createMimeMessage();
            MimeMessageHelper mimeMessageHelper = new MimeMessageHelper(mimeMessage,true);
            mimeMessageHelper.setTo(toMail);
            mimeMessageHelper.setFrom(formMail);
            mimeMessageHelper.setText(html,true);
            mimeMessageHelper.setSubject(subject);
            mailSender.send(mimeMessage);
            System.out.println(&quot;发送html邮件：toMail：&quot;+toMail);
        } catch (Exception e) {
            System.out.println(&quot;发送html邮件异常：toMail：&quot;+toMail);
            e.printStackTrace();
        }
        return false;
    }
}</code></pre>
<h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><pre><code class="java">@RunWith(SpringRunner.class)
@SpringBootTest
public class SpringbootEmailApplicationTests {

    @Resource
    private EmailService emailService;

    @Test
    public void sendSimpleMail() {
        emailService.sendSimpleEmail(&quot;1520151594@qq.com&quot;,&quot;注册提醒&quot;,&quot;欢迎注册，这是一封测试邮件&quot;);
    }

    @Test
    public void sendHtmlMail() {
        emailService.sendHtmlEmail(&quot;1520151594@qq.com&quot;,&quot;注册提醒&quot;,&quot;&lt;h1&gt;欢迎注册，这是一封测试邮件&lt;/h1&gt;&quot;);
    }

}</code></pre>
<p>接收到的邮件</p>
<h6 id="纯文本邮件"><a href="#纯文本邮件" class="headerlink" title="纯文本邮件"></a>纯文本邮件</h6><p><img src="/springboot-mail/%E6%96%87%E6%9C%AC.png" alt></p>
<h6 id="html邮件"><a href="#html邮件" class="headerlink" title="html邮件"></a>html邮件</h6><p><img src="/springboot-mail/html.png" alt></p>
<h4 id="模板邮件"><a href="#模板邮件" class="headerlink" title="模板邮件"></a>模板邮件</h4><p>在发送一些固定场景中，除了使用HTML发送邮件外更常用的是定义一个模板，使用模板发送邮件，然后替换模板中的一些变化的值</p>
<p>以<code>thymeleaf</code>为渲染模板，实现模板的邮件发送</p>
<h5 id="引入thymeleaf依赖"><a href="#引入thymeleaf依赖" class="headerlink" title="引入thymeleaf依赖"></a>引入<code>thymeleaf</code>依赖</h5><pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
<h5 id="定义邮件模板：template-html"><a href="#定义邮件模板：template-html" class="headerlink" title="定义邮件模板：template.html"></a>定义邮件模板：template.html</h5><pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;注册邮件&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;p&gt;&lt;span th:text=&quot;${name}&quot;&gt;&lt;/span&gt;，欢迎注册，这是一封测试邮件&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<h5 id="定义发送模板邮件接口"><a href="#定义发送模板邮件接口" class="headerlink" title="定义发送模板邮件接口"></a>定义发送模板邮件接口</h5><pre><code class="java">/**
 * 发送模板邮件
 * @param toMail 接收邮箱
 * @param subject 标题
 * @param templateValue 模板内容填充值
 * @return
 */
boolean sendTemplateEmail(String toMail,String subject,Map&lt;String,Object&gt; templateValue);</code></pre>
<h5 id="接口实现-1"><a href="#接口实现-1" class="headerlink" title="接口实现"></a>接口实现</h5><pre><code class="java">@Override
public boolean sendTemplateEmail(String toMail, String subject, Map&lt;String,Object&gt; templateValue) {
    System.out.println(&quot;发送html邮件：toMail：&quot;+toMail);
    try {
        MimeMessage mimeMessage = mailSender.createMimeMessage();
        MimeMessageHelper mimeMessageHelper = new MimeMessageHelper(mimeMessage, true);
        mimeMessageHelper.setTo(toMail);
        mimeMessageHelper.setFrom(formMail);
        mimeMessageHelper.setSubject(subject);
        Context context = new Context();
        context.setVariables(templateValue);
        String text = templateEngine.process(&quot;template&quot;,context);
        mimeMessageHelper.setText(text, true);
        mailSender.send(mimeMessage);
        return true;
    } catch (Exception e) {
        System.out.println(&quot;发送html邮件异常：toMail：&quot;+toMail);
        e.printStackTrace();
    }
    return false;
}</code></pre>
<h5 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h5><pre><code class="java">@Test
public void sendTemplateMail() {
    Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();
    map.put(&quot;name&quot;,&quot;叫我明羽&quot;);
    emailService.sendTemplateEmail(&quot;1520151594@qq.com&quot;,&quot;注册提醒&quot;,map);
}</code></pre>
<p>模板邮件</p>
<p><img src="/springboot-mail/%E6%A8%A1%E6%9D%BF.png" alt></p>

			
		</div>
		<footer class="clearfix">
			
				
				
					<div class="disqus-comment">
						<i class="fa fa-comment"></i><a href="https://chenmingyu.top/springboot-mail/#disqus_thread" class="comment-link"> 评论</a>
					</div>
				
			
			
	<div class="categories">
		<i class="fa fa-folder"></i>
		
			<a href="/categories/java/">java</a>
		
	</div>

			
	<div class="tags">
		<i class="fa fa-tags"></i>
		
			<a href="/tags/springboot/">#springboot</a>
		
			<a href="/tags/email/">#email</a>
		
	</div>

		</footer>
	</div>
</article>
	
		
		<article class="post">
	<div class="post-content">
		<header>
			
				<div class="meta">
					<div class="icon">
						
							<i class="fa fa-file"></i>
						
					</div>
					<time datetime="2019-02-21T09:37:49.000Z">2019-02-21</time>
				</div>
			
			
	
		<h1 class="title" data-role="articleTitle"><a href="/design-strategy/">23种设计模式之策略模式</a></h1>
	

		</header>
		<div class="entry">
			
				<h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>策略模式属于行为型模式</p>
<p><strong>定义：</strong>定义一组算法，将每个算法都封装起来，并且使它们之间可以互换</p>
<p>在系统中提供一组策略，并将每个策略封装成类，使他们可以相互转换，具体策略的选择由客户端决定，这就是策略模式，当系统中有很多if…else的时候可以考虑使用策略模式，策略模式可以灵活的增加策略类，进行扩展，但是可能会由于策略过多导致，策略类太多</p>
<h4 id="模式类图"><a href="#模式类图" class="headerlink" title="模式类图"></a>模式类图</h4><p><img src="/design-strategy/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E7%B1%BB%E5%9B%BE.png" alt></p>
<p><strong>角色</strong></p>
<ol>
<li>策略接口：<code>TripStrategy</code></li>
<li>具体策略类：<code>BicycleTripStrategy</code>，<code>CarTripStraregy</code>实现了策略接口的具体策略类</li>
<li>封装策略类：<code>TripContext</code>，使用某种策略的类</li>
</ol>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol>
<li>算法可以自由切换</li>
<li>避免使用多重条件判断</li>
<li>扩展性良好，增加一种策略只需要新增一个策略类</li>
</ol>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol>
<li>策略类数量增多，每新增一种策略，就需要增加一个策略类</li>
<li>所有的策略类都需要对外暴露，上层模块必须知道有哪些策略，然后才能决定使用哪一个策略，违法迪米特法则</li>
</ol>
<h4 id="模式代码实现"><a href="#模式代码实现" class="headerlink" title="模式代码实现"></a>模式代码实现</h4><p><strong>源码地址：<a href="https://github.com/mingyuHub/design-patterns" target="_blank" rel="noopener">https://github.com/mingyuHub/design-patterns</a></strong></p>
<h5 id="策略接口"><a href="#策略接口" class="headerlink" title="策略接口"></a>策略接口</h5><pre><code class="java">/**
 * @author: chenmingyu
 * @date: 2019/2/21 18:15
 * @description: 出行策略
 */
public interface TripStrategy {

    /**
     * 出行方式
     */
    void tripMode();
}</code></pre>
<h5 id="具体策略类"><a href="#具体策略类" class="headerlink" title="具体策略类"></a>具体策略类</h5><p>自行车出行策略类</p>
<pre><code class="java">/**
 * @author: chenmingyu
 * @date: 2019/2/21 18:19
 * @description: 自行车出行策略类
 */
public class BicycleTripStrategy implements TripStrategy{

    @Override
    public void tripMode() {
        System.out.println(&quot;选择骑自行车出行&quot;);
    }
}</code></pre>
<p>开车出行策略类</p>
<pre><code class="java">/**
 * @author: chenmingyu
 * @date: 2019/2/21 18:21
 * @description: 开车出行策略类
 */
public class CarTripStraregy implements TripStrategy {

    @Override
    public void tripMode() {
        System.out.println(&quot;选择开车出行&quot;);
    }
}</code></pre>
<h5 id="封装策略类"><a href="#封装策略类" class="headerlink" title="封装策略类"></a>封装策略类</h5><pre><code class="java">/**
 * @author: chenmingyu
 * @date: 2019/2/21 18:22
 * @description: 策略context
 */
public class TripContext {

    /**
     * 出行策略
     */
    private TripStrategy tripStrategy;

    public TripContext(TripStrategy tripStrategy) {
        this.tripStrategy = tripStrategy;
    }

    /**
     * 选择出行策略
     */
    public void chooseTripMode(){
        this.tripStrategy.tripMode();
    }
}</code></pre>
<h5 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h5><pre><code class="java">public static void main(String[] args) {

    TripContext tripContext = new TripContext(new BicycleTripStrategy());
    tripContext.chooseTripMode();
    System.out.println(&quot;换一种出行方案&quot;);
    tripContext = new TripContext(new CarTripStraregy());
    tripContext.chooseTripMode();
}</code></pre>
<p>输出</p>
<pre><code class="java">选择骑自行车出行
换一种出行方案
选择开车出行</code></pre>
<p>如果系统中的一个策略家族的具体策略数量超过4个，则需要考虑使用混合模式，解决策略类膨胀和对外暴露的问题，否则日后的系统维护就会非常困难</p>
<p><strong>参考：</strong>设计模式之禅：<a href="https://www.kancloud.cn/sstd521/design/193569" target="_blank" rel="noopener">https://www.kancloud.cn/sstd521/design/193569</a></p>
<p><strong>推荐阅读：</strong><a href="https://chenmingyu.top/design/">23种设计模式详解</a></p>

			
		</div>
		<footer class="clearfix">
			
				
				
					<div class="disqus-comment">
						<i class="fa fa-comment"></i><a href="https://chenmingyu.top/design-strategy/#disqus_thread" class="comment-link"> 评论</a>
					</div>
				
			
			
	<div class="categories">
		<i class="fa fa-folder"></i>
		
			<a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
		
	</div>

			
	<div class="tags">
		<i class="fa fa-tags"></i>
		
			<a href="/tags/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/">#策略模式</a>
		
	</div>

		</footer>
	</div>
</article>
	
		
		<article class="post">
	<div class="post-content">
		<header>
			
				<div class="meta">
					<div class="icon">
						
							<i class="fa fa-file"></i>
						
					</div>
					<time datetime="2019-02-18T08:04:32.000Z">2019-02-18</time>
				</div>
			
			
	
		<h1 class="title" data-role="articleTitle"><a href="/design-adapter/">设计模式总结：适配器模式</a></h1>
	

		</header>
		<div class="entry">
			
				<h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>适配器模式属于结构型模式,又叫包装模式</p>
<p><strong>定义：</strong>把一个类的接口变换成客户端所期待的另一种接口，从而使原本接口不匹配而无法一起工作的两个类能够在一起工作</p>
<p>在现有的系统中有新旧两个接口，由于新旧接口不兼容导致客户端调用出现问题，但是现有系统还需要使用旧的接口，所以这个接口不能重构，但是为了能够让客户端正常调用，我们就需要将新的接口转换成旧的接口，这种解决方式就是适配器模式</p>
<h4 id="模式类图"><a href="#模式类图" class="headerlink" title="模式类图"></a>模式类图</h4><p><img src="/design-adapter/%E7%B1%BB%E5%9B%BE.png" alt></p>
<p><strong>角色：</strong></p>
<ol>
<li>目标接口：Target，该角色把其他类转换为我们期望的接口</li>
<li>被适配类：Adaptee，被期望改变的接口</li>
<li>适配器：adapter，将被适配类Adaptee和目标接口Target接口组合到一起</li>
</ol>
<h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ol>
<li>适配器模式可以让两个没有任何关系的类在一起运行</li>
<li>增加了类的透明性和复用性</li>
<li>灵活性非常好</li>
</ol>
<p>适配器模式是为了在扩展应用的时候减少代码时才使用的，所以最初设计系统时不要考虑使用适配器模式</p>
<h4 id="模式代码实现"><a href="#模式代码实现" class="headerlink" title="模式代码实现"></a>模式代码实现</h4><p><strong>源码地址：<a href="https://github.com/mingyuHub/design-patterns" target="_blank" rel="noopener">https://github.com/mingyuHub/design-patterns</a></strong></p>
<h5 id="目标接口"><a href="#目标接口" class="headerlink" title="目标接口"></a>目标接口</h5><p><code>Target</code>，我们期望的接口模样，供客户端调用</p>
<pre><code class="java">/**
 * @author: chenmingyu
 * @date: 2019/2/18 18:38
 * @description: 目标接口
 */
public interface Target {

    /**
     * 客户端访问的目标接口
     */
    void request();
}</code></pre>
<h5 id="被适配类"><a href="#被适配类" class="headerlink" title="被适配类"></a>被适配类</h5><p><code>Adaptee</code>的<code>adapterMethod</code>方法是我们期望被适配的方法</p>
<pre><code class="java">/**
 * @author: chenmingyu
 * @date: 2019/2/18 19:20
 * @description: 被适配类
 */
public class Adaptee {

    /**
     * 被适配的接口
     */
    public void adapterMethod(){
        System.out.println(&quot;我是要被适配的方法&quot;);
    };
}</code></pre>
<h5 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h5><p><code>Adapter</code>，将被适配类Adaptee和目标接口Target接口组合到一起</p>
<pre><code class="java">/**
 * @author: chenmingyu
 * @date: 2019/2/18 19:20
 * @description: 适配器
 */
public class Adapter implements Target {

    /**
     * 被适配类
     */
    private Adaptee adaptee;

    public Adapter(Adaptee adaptee) {
        this.adaptee = adaptee;
    }

    @Override
    public void request() {
        adaptee.adapterMethod();
    }
}</code></pre>
<h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><pre><code class="java">public static void main(String[] args) {
    Adaptee adaptee = new Adaptee();
    Adapter adapter = new Adapter(adaptee);
    adapter.request();
}</code></pre>
<p>输出</p>
<pre><code class="java">我是要被适配的方法</code></pre>
<p><strong>参考：</strong>设计模式之禅：<a href="https://www.kancloud.cn/sstd521/design/193573" target="_blank" rel="noopener">https://www.kancloud.cn/sstd521/design/193573</a></p>
<p><strong>推荐阅读：</strong><a href="https://chenmingyu.top/design/">23种设计模式详解</a></p>

			
		</div>
		<footer class="clearfix">
			
				
				
					<div class="disqus-comment">
						<i class="fa fa-comment"></i><a href="https://chenmingyu.top/design-adapter/#disqus_thread" class="comment-link"> 评论</a>
					</div>
				
			
			
	<div class="categories">
		<i class="fa fa-folder"></i>
		
			<a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
		
	</div>

			
	<div class="tags">
		<i class="fa fa-tags"></i>
		
			<a href="/tags/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/">#适配器模式</a>
		
	</div>

		</footer>
	</div>
</article>
	
		
		<article class="post">
	<div class="post-content">
		<header>
			
				<div class="meta">
					<div class="icon">
						
							<i class="fa fa-file"></i>
						
					</div>
					<time datetime="2019-02-14T02:17:39.000Z">2019-02-14</time>
				</div>
			
			
	
		<h1 class="title" data-role="articleTitle"><a href="/design-factory-method/">23种设计模式之工厂方法模式</a></h1>
	

		</header>
		<div class="entry">
			
				<h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><p>工厂模式属于创建型设计模式</p>
<p><strong>定义：</strong>定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类</p>
<p>工厂方法模式是new一个对象的替代品，所以在所有需要生成对象的地方都可以使用，但如果随意增加工厂类会增加代码的复杂度，也不易维护</p>
<h4 id="模式类图"><a href="#模式类图" class="headerlink" title="模式类图"></a>模式类图</h4><p><img src="/design-factory-method/uml.png" alt></p>
<p><strong>角色</strong></p>
<ol>
<li>抽象产品：<code>Product</code>抽象产品定义</li>
<li>具体产品类：<code>ConcreteProduct</code>实现<code>Product</code>接口</li>
<li>抽象工厂：<code>Creatot</code>抽象工厂定义</li>
<li>具体工厂类：<code>ConcreteCreator</code>实现<code>Creatot</code>接口</li>
</ol>
<h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ol>
<li>解耦：调用方不用负责对象的创建，只需要使用，明确各自的职责</li>
<li>维护方便：后期如果创建对象时需要修改代码，也只需要去工厂方法中修改，易拓展</li>
</ol>
<h4 id="模式代码实现"><a href="#模式代码实现" class="headerlink" title="模式代码实现"></a>模式代码实现</h4><p><strong>源码地址：<a href="https://github.com/mingyuHub/design-patterns" target="_blank" rel="noopener">https://github.com/mingyuHub/design-patterns</a></strong></p>
<p>工厂方法模式可以分为：简单工厂和工厂方法</p>
<h4 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h4><p>以游戏为例子，涉及四个类：GameFactory（游戏工厂类），Gameable（游戏接口），ShootGame（射击类游戏），TowerDefenceGame（塔防类游戏）</p>
<p>比如游戏工厂，工厂方法通过出入的参数生成生成不同产品类型的游戏</p>
<h5 id="Gameable"><a href="#Gameable" class="headerlink" title="Gameable"></a>Gameable</h5><p>游戏接口，提供一个校验账户信息的接口</p>
<pre><code class="java">/**
 * @auther: chenmingyu
 * @date: 2019/2/14 11:19
 * @description:
 */
public interface Gameable {

    /**
     * 校验账户信息
     * @param nickName
     */
    void validateAccount(String nickName);
}</code></pre>
<h5 id="ShootGame"><a href="#ShootGame" class="headerlink" title="ShootGame"></a>ShootGame</h5><p>射击类游戏，实现Gameable接口</p>
<pre><code class="java">/**
 * @auther: chenmingyu
 * @date: 2019/2/14 11:26
 * @description: 射击类游戏
 */
public class ShootGame implements Gameable{

    @Override
    public void validateAccount(String nickName) {
        System.out.println(&quot;射击游戏校验昵称：&quot;+nickName);
    }
}</code></pre>
<h5 id="TowerDefenceGame"><a href="#TowerDefenceGame" class="headerlink" title="TowerDefenceGame"></a>TowerDefenceGame</h5><p>塔防类游戏，实现Gameable接口</p>
<pre><code class="java">/**
 * @auther: chenmingyu
 * @date: 2019/2/14 11:28
 * @description: 塔防类游戏
 */
public class TowerDefenceGame implements Gameable{

    @Override
    public void validateAccount(String nickName) {
        System.out.println(&quot;塔防游戏校验昵称：&quot;+nickName);
    }
}</code></pre>
<h5 id="GameFactory"><a href="#GameFactory" class="headerlink" title="GameFactory"></a>GameFactory</h5><p>游戏工厂，封装了创建游戏对象的过程</p>
<pre><code class="java">/**
 * @auther: chenmingyu
 * @date: 2019/2/14 11:29
 * @description: 工厂类
 */
public class GameFactory {

    /**
     * 根据传入类型生成实例
     * @param gameType
     * @return
     */
    public static Gameable creator(String gameType){
        Gameable gameable = null;
        if(StringUtils.isEmpty(gameType)){
            return gameable;
        }
        if(&quot;shoot&quot;.equalsIgnoreCase(gameType)){
            gameable = new ShootGame();
        }else if(&quot;towerDefence&quot;.equalsIgnoreCase(gameType)){
            gameable = new TowerDefenceGame();
        }
        return gameable;
    }
}</code></pre>
<h5 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h5><p>客户端决定实例化哪个对象</p>
<pre><code class="java">public static void main(String[] args) {
    Gameable shootGame = GameFactory.creator(&quot;shoot&quot;);
    shootGame.validateAccount(&quot;明羽&quot;);
    System.out.println(&quot;... 分割线 ...&quot;);
    Gameable towerDefenceGame = GameFactory.creator(&quot;towerDefence&quot;);
    towerDefenceGame.validateAccount(&quot;明羽&quot;);
}</code></pre>
<p>输出</p>
<pre><code class="java">射击游戏校验昵称：明羽
... 分割线 ...
塔防游戏校验昵称：明羽</code></pre>
<p>如果要新增一个拳击类游戏的话，就需要新建一个拳击游戏类，然后修改工厂方法。</p>
<h4 id="工厂方法模式-1"><a href="#工厂方法模式-1" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h4><p>工厂模式跟简单工厂模式的区别在于简单工厂只有一个工厂类，提供了一个工厂方法，由入参决定生产那个产品，而工厂模式则定义一个工厂接口，不同的产品工厂实现工厂接口，生产的产品由产品工厂决定</p>
<p>以游戏为例子，在上面四个类的基础上修改GameFactory（游戏工厂类）为接口，新增了两个类：ShootGameFactory（射击类游戏工厂），TowerDefenceGameFactory（塔防类游戏工厂）</p>
<h5 id="修改了的GameFactory"><a href="#修改了的GameFactory" class="headerlink" title="修改了的GameFactory"></a>修改了的GameFactory</h5><pre><code class="java">/**
 * @auther: chenmingyu
 * @date: 2019/2/14 11:29
 * @description: 工厂类
 */
public interface GameFactory {

    /**
     * 生成实例
     * @return
     */
    Gameable creator();
}</code></pre>
<h5 id="ShootGameFactory"><a href="#ShootGameFactory" class="headerlink" title="ShootGameFactory"></a>ShootGameFactory</h5><p>实现GameFactory，重写creator()</p>
<pre><code class="java">/**
 * @auther: chenmingyu
 * @date: 2019/2/14 15:14
 * @description: 射击类游戏工厂
 */
public class ShootGameFactory implements GameFactory{

    @Override
    public Gameable creator() {
        return new ShootGame();
    }
}</code></pre>
<h5 id="TowerDefenceGameFactory"><a href="#TowerDefenceGameFactory" class="headerlink" title="TowerDefenceGameFactory"></a>TowerDefenceGameFactory</h5><p>实现GameFactory，重写creator()</p>
<pre><code class="java">/**
 * @auther: chenmingyu
 * @date: 2019/2/14 15:15
 * @description: 塔防类游戏工厂
 */
public class TowerDefenceGameFactory implements GameFactory{

    @Override
    public Gameable creator() {
        return new TowerDefenceGame();
    }
}</code></pre>
<h5 id="验证-1"><a href="#验证-1" class="headerlink" title="验证"></a>验证</h5><pre><code class="java">/**
 * @auther: chenmingyu
 * @date: 2019/2/14 11:38
 * @description:
 */
public class FactoryTest {

    public static void main(String[] args) {

        GameFactory shootGameFactory = new ShootGameFactory();
        Gameable shootGame = shootGameFactory.creator();
        shootGame.validateAccount(&quot;明羽&quot;);
        System.out.println(&quot;... 分割线 ...&quot;);
        GameFactory towerDefenceGameFactory = new TowerDefenceGameFactory();
        Gameable towerDefenceGame = towerDefenceGameFactory.creator();
        towerDefenceGame.validateAccount(&quot;明羽&quot;);
    }
}</code></pre>
<p>输出</p>
<pre><code class="java">射击游戏校验昵称：明羽
... 分割线 ...
塔防游戏校验昵称：明羽</code></pre>
<p><strong>推荐阅读：</strong><a href="https://chenmingyu.top/design/">23种设计模式详解</a></p>

			
		</div>
		<footer class="clearfix">
			
				
				
					<div class="disqus-comment">
						<i class="fa fa-comment"></i><a href="https://chenmingyu.top/design-factory-method/#disqus_thread" class="comment-link"> 评论</a>
					</div>
				
			
			
	<div class="categories">
		<i class="fa fa-folder"></i>
		
			<a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
		
	</div>

			
	<div class="tags">
		<i class="fa fa-tags"></i>
		
			<a href="/tags/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/">#工厂模式</a>
		
	</div>

		</footer>
	</div>
</article>
	

	<nav id="pagination">
	
		<a href="/page/5/" class="prev"><i class="fa fa-chevron-left"></i> 上一页</a>
	
	
		<a href="/page/7/" class="next">下一页 <i class="fa fa-chevron-right"></i></a>
	
</nav>

	
<script>
	(function (disqus_shortname) {
		window.addEventListener('DOMContentLoaded', function () {
			var dsq = document.createElement('script');
			dsq.type = 'text/javascript';
			dsq.async = true;
			dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
			document.getElementsByTagName('head')[0].appendChild(dsq);
		}, false);
	}('dnxbf321'));
</script>



		</div>
		
	</div>
</div>

<footer id="footer">
	<div class="center">
		&copy; 2022
		
			明羽
		.
		&nbsp;&nbsp;
		Blog generated by <a href="http://hexo.io" target="_blank" rel="noopener">hexo</a>
	</div>
</footer>

<script src="/bower_components/jquery/dist/jquery.min.js"></script>
<script src="/js/header-animate.js"></script>


	<script src="/js/title-animate.js"></script>


<script src="/bower_components/jquery_lazyload/jquery.lazyload.js"></script>
<script>
	$('img.lazy').lazyload();
</script>

	<script src="/bower_components/fancybox/source/jquery.fancybox.pack.js"></script>
	<script>
		$('.fancybox').fancybox();
	</script>




</body>
</html>