<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>但行好事 莫问前程</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="但行好事 莫问前程">
<meta property="og:url" content="https://chenmingyu.top/page/4/index.html">
<meta property="og:site_name" content="但行好事 莫问前程">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="陈明羽">
<meta property="article:tag" content="陈明羽">
<meta property="article:tag" content="chenmingyu">
<meta property="article:tag" content="java">
<meta property="article:tag" content="架构">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="但行好事 莫问前程" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">但行好事 莫问前程</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">明羽</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://chenmingyu.top"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-design-memento" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/design-memento/" class="article-date">
  <time datetime="2019-03-25T12:27:55.000Z" itemprop="datePublished">2019-03-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/design-memento/">23种设计模式之备忘录模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h3><p>备忘录模式属于行为型模式</p>
<p><strong>定义：</strong>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态</p>
<p>其实就是在某个时刻备份了对象的状态，在更改对象状态后，可以通过备份将对象还原成备份时刻的状态</p>
<h4 id="模式类图"><a href="#模式类图" class="headerlink" title="模式类图"></a>模式类图</h4><p><img src="design-memento/uml.png" alt=""></p>
<p><strong>角色</strong></p>
<ol>
<li>原始对象：<code>Originator</code> 原对象，提供创建备份，和恢复备份数据功能</li>
<li>备忘录：<code>Memento</code>负责存储<code>Originator</code>对象的内部状态，在需要的时候提供发起人需要的内部状态</li>
<li>备忘录管理员：<code>Caretaker</code>对备忘录进行管理、保存和提供备忘录</li>
</ol>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol>
<li>提供一种可以备份恢复的机制，客户端可以方便的恢复某个历史状态</li>
<li>封装性好，客户端不需要关心状态的保存细节</li>
</ol>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>如果状态太多，会导致类膨胀</p>
<h4 id="模式代码实现"><a href="#模式代码实现" class="headerlink" title="模式代码实现"></a>模式代码实现</h4><p><strong>源码地址：<a href="https://github.com/mingyuHub/design-patterns" target="_blank" rel="noopener">https://github.com/mingyuHub/design-patterns</a></strong></p>
<h5 id="原始对象"><a href="#原始对象" class="headerlink" title="原始对象"></a>原始对象</h5><p>提供创建备份，和恢复备份数据功能</p>
<pre><code class="java">/**
 * @author: chenmingyu
 * @date: 2019/3/25 20:42
 * @description: 原始对象
 */
@Data
public class Originator{

    private String name;

    /**
     * 创建备忘录
     * @return
     * @throws CloneNotSupportedException
     */
    public Memento createMemento(){
        return new Memento(this.getName());
    }

    /**
     * 恢复一个备忘录
     * @param memento
     */
    public void restoreMemento(Memento memento){
        this.setName(memento.getName());
    }

    public Originator(String name) {
        this.name = name;
    }
}</code></pre>
<h5 id="备忘录"><a href="#备忘录" class="headerlink" title="备忘录"></a>备忘录</h5><p>负责存储<code>Originator</code>的内在状态</p>
<pre><code class="java">/**
 * @author: chenmingyu
 * @date: 2019/3/25 20:47
 * @description: 备忘录
 */
@Data
public class Memento {

    private String name;

    public Memento(String name) {
        this.name = name;
    }
}</code></pre>
<h5 id="备忘录管理员"><a href="#备忘录管理员" class="headerlink" title="备忘录管理员"></a>备忘录管理员</h5><p>持有<code>Memento</code>d的实例</p>
<pre><code class="java">/**
 * @author: chenmingyu
 * @date: 2019/3/25 20:57
 * @description: 备忘录管理员
 */
@Data
public class Caretaker {

    private Memento memento;

    public Caretaker(Memento memento) {
        this.memento = memento;
    }
}</code></pre>
<h5 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h5><pre><code class="java">public static void main(String[] args) {
    Originator originator = new Originator(&quot;mingyu&quot;);
    Caretaker caretaker = new Caretaker(originator.createMemento());
    System.out.println(originator.getName());
    System.out.println(&quot;……&quot;);

    originator.setName(&quot;wuwu&quot;);
    System.out.println(originator.getName());

    System.out.println(&quot;……&quot;);
    originator.restoreMemento(caretaker.getMemento());
    System.out.println(originator.getName());
}</code></pre>
<p>输出</p>
<pre><code class="java">mingyu
……
wuwu
……
mingyu</code></pre>
<p><strong>参考：</strong>设计模式之禅：<a href="https://www.kancloud.cn/sstd521/design/193597" target="_blank" rel="noopener">https://www.kancloud.cn/sstd521/design/193597</a></p>
<p><strong>推荐阅读：</strong><a href="https://chenmingyu.top/design/">23种设计模式详解</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://chenmingyu.top/design-memento/" data-id="ckdn6w7yn001maktw30z23x38" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/" rel="tag">备忘录模式</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-design-command" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/design-command/" class="article-date">
  <time datetime="2019-03-23T12:45:40.000Z" itemprop="datePublished">2019-03-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/design-command/">23种设计模式之命令模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><p>命令模式属于行为型模式</p>
<p><strong>定义：</strong>将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能</p>
<h4 id="模式类图"><a href="#模式类图" class="headerlink" title="模式类图"></a>模式类图</h4><p><img src="design-command/uml.png" alt=""></p>
<p><strong>角色：</strong></p>
<ol>
<li>接受者：<code>Receiver</code>最后的执行者，具体的业务逻辑</li>
<li>命令接口：<code>Command</code>需要执行的所有命令都在这里声明</li>
<li>具体命令：<code>ConcreteCommand</code>实现<code>Command</code>接口</li>
<li>调用者：<code>Invoker</code>接收到命令，并执行命令，命令中调用接受者</li>
</ol>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol>
<li>降低类之间解耦，调用者与接受者之间没有任何依赖关系</li>
<li>扩展性高，非常容易地扩展<code>Command</code>类的子类</li>
</ol>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>如果命令比较多，<code>Command</code>类的子类就会变得非常的多</p>
<h4 id="模式代码实现"><a href="#模式代码实现" class="headerlink" title="模式代码实现"></a>模式代码实现</h4><p><strong>源码地址：<a href="https://github.com/mingyuHub/design-patterns" target="_blank" rel="noopener">https://github.com/mingyuHub/design-patterns</a></strong></p>
<p>接受者有两个方法，打游戏和学习，通过实现命令接口写了两个具体的命令实现类，分别代表玩游戏命令和学习命令，通过调用者去调用不同的命令</p>
<h5 id="接受者"><a href="#接受者" class="headerlink" title="接受者"></a>接受者</h5><pre><code class="java">/**
 * @author: chenmingyu
 * @date: 2019/3/25 10:48
 * @description: 接受者角色
 */
public class Receive {

    public void play(){
        System.out.println(&quot;打游戏吧&quot;);
    }

    public void study(){
        System.out.println(&quot;要学习了&quot;);
    }
}</code></pre>
<h5 id="命令接口"><a href="#命令接口" class="headerlink" title="命令接口"></a>命令接口</h5><pre><code class="java">/**
 * @author: chenmingyu
 * @date: 2019/3/25 10:51
 * @description: 命令接口
 */
public interface Commandable {

    /**
     * 命令执行接口
     */
    void execute();
}</code></pre>
<h5 id="玩游戏命令"><a href="#玩游戏命令" class="headerlink" title="玩游戏命令"></a>玩游戏命令</h5><p>持有<code>receive</code>实例</p>
<pre><code class="java">/**
 * @author: chenmingyu
 * @date: 2019/3/25 10:52
 * @description: 玩游戏命令
 */
public class GameCommand implements Commandable{

    private Receive receive;

    public GameCommand(Receive receive) {
        this.receive = receive;
    }

    @Override
    public void execute() {
        this.receive.play();
    }
}</code></pre>
<h5 id="学习命令"><a href="#学习命令" class="headerlink" title="学习命令"></a>学习命令</h5><p>持有<code>receive</code>实例</p>
<pre><code class="java">/**
 * @author: chenmingyu
 * @date: 2019/3/25 10:54
 * @description: 学习命令
 */
public class StudyCommand implements Commandable {

    private Receive receive;

    public StudyCommand(Receive receive) {
        this.receive = receive;
    }

    @Override
    public void execute() {
        this.receive.study();
    }
}</code></pre>
<h5 id="调用者"><a href="#调用者" class="headerlink" title="调用者"></a>调用者</h5><p>持有<code>Commandable</code>的实现类的实例</p>
<pre><code class="java">/**
 * @author: chenmingyu
 * @date: 2019/3/25 10:51
 * @description: 调用者
 */
@Data
public class Invoker {

    /**
     * 持有Commandable的实现类的实例
     */
    private Commandable commandable;

    /**
     * 执行命令
     */
    public void action(){
        this.commandable.execute();
    }
}</code></pre>
<h5 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h5><pre><code class="java">public static void main(String[] args) {

    Invoker invoker = new Invoker();
    Receive receive = new Receive();

    Commandable gameCommand = new GameCommand(receive);
    invoker.setCommandable(gameCommand);
    invoker.action();

    Commandable studyCommand = new StudyCommand(receive);
    invoker.setCommandable(studyCommand);
    invoker.action();
}</code></pre>
<p>输出</p>
<pre><code class="java">打游戏吧
要学习了</code></pre>
<p><strong>参考：</strong>设计模式之禅：<a href="https://www.kancloud.cn/sstd521/design/193555" target="_blank" rel="noopener">https://www.kancloud.cn/sstd521/design/193555</a></p>
<p><strong>推荐阅读：</strong><a href="https://chenmingyu.top/design/">23种设计模式详解</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://chenmingyu.top/design-command/" data-id="ckdn6w7y0000taktw4y8wgx3x" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/" rel="tag">命令模式</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-design-chain" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/design-chain/" class="article-date">
  <time datetime="2019-03-22T10:11:17.000Z" itemprop="datePublished">2019-03-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/design-chain/">23种设计模式之责任链模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h3><p>责任链模式属于行为型模式</p>
<p><strong>定义：</strong>使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止</p>
<p>每个对象持有对下一个对象的引用，形成一条链，请求在这条链上传递，直到某一对象决定处理该请求。但是发出者并不清楚到底最终那个对象会处理该请求.</p>
<h4 id="模式类图"><a href="#模式类图" class="headerlink" title="模式类图"></a>模式类图</h4><p><img src="design-chain/uml.png" alt=""></p>
<p><strong>角色</strong></p>
<ol>
<li>抽象处理接口：Handler</li>
<li>具体处理类：ConcreteHandler</li>
</ol>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>将请求与处理分开，请求者可以不用知道到底是需要谁来处理的，两者解耦，提高系统灵活性，增加新的请求处理类很方便</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>当调用链比较长的时候，调试不方便，写代码时要注意避免循环调用</p>
<h4 id="模式代码实现"><a href="#模式代码实现" class="headerlink" title="模式代码实现"></a>模式代码实现</h4><p><strong>源码地址：<a href="https://github.com/mingyuHub/design-patterns" target="_blank" rel="noopener">https://github.com/mingyuHub/design-patterns</a></strong></p>
<p>以用户注册为例，注册方式分为普通用户注册和Vip用户注册，使用责任链模式将两种注册方式链起来</p>
<h5 id="抽象处理接口"><a href="#抽象处理接口" class="headerlink" title="抽象处理接口"></a>抽象处理接口</h5><p>抽象接口定义了两个方法：用户注册方法，责任链调用方法</p>
<pre><code class="java">/**
 * @author: chenmingyu
 * @date: 2019/3/22 20:32
 * @description:
 */
public interface Handler {

    /**
     * 注册操作
     * @param userName 用户名
     */
    String operator(String userName);

    /**
     * 责任链调用处理逻辑
     *      如果可以自己处理则自己处理，如果处理不了，交由下一个处理类处理
     * @param level
     * @param userName
     * @return
     */
    String handleMessage(Integer level,String userName);
}
</code></pre>
<h5 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h5><p>继承<code>Handler</code>，<code>getUserLevel()</code>交由子类实现，<code>handleMessage(Integer level,String userName)</code>用final修饰，子类无法重写责任链调用的处理逻辑</p>
<pre><code class="java">/**
 * @author: chenmingyu
 * @date: 2019/3/23 10:42
 * @description: 抽象类
 */
@Data
public abstract class AbstractHandle implements Handler {

    /**
     * 下一个处理器
     */
    public Handler nextHandler;

    /**
     * 获取用户等级
     * @return
     */
    protected abstract Integer getUserLevel();

    @Override
    public final String handleMessage(Integer level,String userName){
        String result = &quot;&quot;;
        if(this.getUserLevel().equals(level)){
            result = this.operator(userName);
        }else{
            result = this.nextHandler.handleMessage(level,userName);
        }
        return result;
    }
}</code></pre>
<h5 id="具体实现类"><a href="#具体实现类" class="headerlink" title="具体实现类"></a>具体实现类</h5><p>普通会员</p>
<pre><code class="java">/**
 * @author: chenmingyu
 * @date: 2019/3/23 10:46
 * @description: 普通用户注册
 */
@Data
public class UserRegisterHandle extends AbstractHandle {

    /**
     * 普通会员
     */
    public Integer ordinaryLevel = 1;

    @Override
    public String operator(String userName) {
        System.out.println(&quot;普通会员注册：&quot;+userName);
        return userName;
    }

    @Override
    protected Integer getUserLevel() {
        return ordinaryLevel;
    }
}</code></pre>
<p>vip会员</p>
<pre><code class="java">/**
 * @author: chenmingyu
 * @date: 2019/3/23 11:02
 * @description: vip会员注册
 */
public class VIPUserRegisterHandle extends AbstractHandle {

    /**
     * VIP会员
     */
    public Integer VIPLevel = 2;

    @Override
    public String operator(String userName) {
        System.out.println(&quot;VIP会员注册：&quot;+userName);
        return userName;
    }

    @Override
    protected Integer getUserLevel() {
        return VIPLevel;
    }
}</code></pre>
<h5 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h5><pre><code class="java">public static void main(String[] args) {

    UserRegisterHandle userRegisterHandle = new UserRegisterHandle();
    VIPUserRegisterHandle vipUserRegisterHandle = new VIPUserRegisterHandle();
    userRegisterHandle.setNextHandler(vipUserRegisterHandle);

    userRegisterHandle.handleMessage(2,&quot;mingyu&quot;);
    userRegisterHandle.handleMessage(1,&quot;mingyu&quot;);
}</code></pre>
<p>输出</p>
<pre><code class="java">VIP会员注册：mingyu
普通会员注册：mingyu</code></pre>
<p><strong>参考：</strong>设计模式之禅：<a href="https://www.kancloud.cn/sstd521/design/193560" target="_blank" rel="noopener">https://www.kancloud.cn/sstd521/design/193560</a></p>
<p><strong>推荐阅读：</strong><a href="https://chenmingyu.top/design/">23种设计模式详解</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://chenmingyu.top/design-chain/" data-id="ckdn6w7xw000saktwhnxbebzl" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/" rel="tag">责任链模式</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-design-observer" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/design-observer/" class="article-date">
  <time datetime="2019-03-15T01:57:57.000Z" itemprop="datePublished">2019-03-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/design-observer/">23种设计模式之观察者模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>观察者模式属于行为型模式，又叫发布订阅模式</p>
<p><strong>定义：</strong></p>
<p>​    定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新</p>
<h4 id="模式类图"><a href="#模式类图" class="headerlink" title="模式类图"></a>模式类图</h4><p><img src="design-observer/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20190315105847.png" alt=""></p>
<p><strong>角色：</strong></p>
<ol>
<li>被观察者：<code>Subject</code>定义一个被观察者必须实现职责，包括动态增加，删除，通知观察者</li>
<li>观察者：<code>Observer</code>接受到观察者修改消息，执行自身逻辑</li>
<li>具体观察者：<code>ConctreteSubject</code>继承<code>Subject</code>，拥有自己的业务逻辑，具有被观察者基本功能，对某些事件进行通知</li>
<li>具体的观察者：<code>ConcreteObserver</code>具体观察者，在接受到被观察者变更消息后，进行各自业务处理</li>
</ol>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol>
<li>观察者和被观察者之间是抽象耦合，容易拓展</li>
<li>通过触发机制可以创建成一种链式触发机制，形成多级触发</li>
</ol>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol>
<li><p>执行效率</p>
<p>当通知观察者是顺序执行时，需要考虑整个观察者列表的数量，对整个通知事件执行效率的影响，可以考虑使用异步通知，同时尽量避免多级触发事件</p>
</li>
<li><p>循环依赖</p>
<p>当观察者和被观察之间形成循环依赖，会导致循环调用，比如A改变通知B，B改变通知C，C改变通知A，注意避免循环依赖的发生</p>
</li>
</ol>
<h4 id="模式代码实现"><a href="#模式代码实现" class="headerlink" title="模式代码实现"></a>模式代码实现</h4><p>以用户修改密码为例，当用户密码改变后，使用短信和邮件对用户进行消息提醒</p>
<p><strong>源码地址：<a href="https://github.com/mingyuHub/design-patterns" target="_blank" rel="noopener">https://github.com/mingyuHub/design-patterns</a></strong></p>
<h5 id="被观察者接口"><a href="#被观察者接口" class="headerlink" title="被观察者接口"></a>被观察者接口</h5><p><code>Subjectable</code> 定义被观察者基本功能</p>
<pre><code class="java">/**
 * @author: chenmingyu
 * @date: 2019/3/15 13:44
 * @description: 被观察者接口
 */
public interface Subjectable {

    /**
     * 增加观察者
     */
    void addObserver(Observerable observer);

    /**
     * 移除观察者
     */
    void removeObserver(Observerable observer);

    /**
     * 通知观察者
     */
    void notifyObserver(Object object);
}</code></pre>
<h5 id="被观察者抽象类"><a href="#被观察者抽象类" class="headerlink" title="被观察者抽象类"></a>被观察者抽象类</h5><p><code>AbstractSubject</code>被观察者类的公共父类，实现了被观察者基本功能的实现，使用<code>Vector</code>为观察者列表</p>
<pre><code class="java">/**
 * @author: chenmingyu
 * @date: 2019/3/15 11:24
 * @description: 被观察者抽象类
 */
public abstract class AbstractSubject implements Subjectable{

    /**
     * 观察者列表
     */
    private Vector&lt;Observerable&gt; observers = new Vector();

    @Override
    public void addObserver(Observerable observer){
        observers.add(observer);
    }

    @Override
    public void removeObserver(Observerable observer){
        observers.add(observer);
    }

    @Override
    public void notifyObserver(Object object){
        observers.forEach(observer-&gt;{
            observer.update(object);
        });
    }
}</code></pre>
<h5 id="被观察者类"><a href="#被观察者类" class="headerlink" title="被观察者类"></a>被观察者类</h5><p><code>UserInfo</code>实现<code>AbstractSubject</code></p>
<pre><code class="java">/**
 * @author: chenmingyu
 * @date: 2019/3/15 13:50
 * @description: 被观察者
 */
@Data
public class UserInfo extends AbstractSubject{

    /**
     * 昵称
     */
    private String nickName;
    /**
     * 密码
     */
    private String password;

    /**
     * 修改密码
     * @param password
     */
    public void updatePassword(String password){
        this.password = password;
        this.notifyObserver(password);
    }

    public UserInfo(String nickName, String password) {
        this.nickName = nickName;
        this.password = password;
    }
}</code></pre>
<h5 id="观察者接口"><a href="#观察者接口" class="headerlink" title="观察者接口"></a>观察者接口</h5><pre><code class="java">/**
 * @author: chenmingyu
 * @date: 2019/3/15 13:40
 * @description: 观察者
 */
public interface Observerable {

    /**
     * 被观察者变化触发事件
     */
    void update(Object object);
}</code></pre>
<h5 id="具体观察者"><a href="#具体观察者" class="headerlink" title="具体观察者"></a>具体观察者</h5><p><code>SmsObserver</code> 接收到被观察者密码变更，发送短信提醒</p>
<pre><code class="java">/**
 * @author: chenmingyu
 * @date: 2019/3/15 13:56
 * @description: 短信观察者
 */
public class SmsObserver implements Observerable {

    @Override
    public void update(Object object) {
        if(null == object){
            return;
        }
        System.out.println(&quot;短信观察者&quot;);
        System.out.println(&quot;短信发送提醒：密码更改为：&quot;+object.toString());
    }
}</code></pre>
<p><code>EmailObserver</code> 接收到被观察者密码变更，发送邮件提醒</p>
<pre><code class="java">/**
 * @author: chenmingyu
 * @date: 2019/3/15 13:54
 * @description: 邮件观察者
 */
public class EmailObserver implements Observerable{

    @Override
    public void update(Object object) {
        if(null == object){
            return;
        }
        System.out.println(&quot;邮件观察者&quot;);
        System.out.println(&quot;邮件发送提醒：密码更改为：&quot;+object.toString());
    }
}</code></pre>
<h5 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h5><pre><code class="java">public static void main(String[] args) {

    UserInfo userInfo = new UserInfo(&quot;麻辣香锅&quot;,&quot;malaxiangguo&quot;);

    SmsObserver smsObserver = new SmsObserver();
    EmailObserver emailObserver = new EmailObserver();

    userInfo.addObserver(smsObserver);
    userInfo.addObserver(emailObserver);

    userInfo.updatePassword(&quot;mlxg&quot;);
}</code></pre>
<p>输出</p>
<pre><code class="java">短信观察者
短信发送提醒：密码更改为：mlxg
邮件观察者
邮件发送提醒：密码更改为：mlxg</code></pre>
<p><code>SmsObserver</code>和<code>EmailObserver</code>观察到<code>UserInfo</code>用户麻辣香锅更改密码为mlxg</p>
<p><strong>参考：</strong>设计模式之禅：<a href="https://www.kancloud.cn/sstd521/design/193589" target="_blank" rel="noopener">https://www.kancloud.cn/sstd521/design/193589</a></p>
<p><strong>推荐阅读：</strong><a href="https://chenmingyu.top/design/">23种设计模式详解</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://chenmingyu.top/design-observer/" data-id="ckdn6w7yt001paktw9r9e7tcf" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/" rel="tag">观察者模式</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-design-composite" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/design-composite/" class="article-date">
  <time datetime="2019-03-12T09:27:42.000Z" itemprop="datePublished">2019-03-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/design-composite/">23种设计模式之组合模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h3><p>组合模式属于属于结构型模式，又叫部分整体模式</p>
<p><strong>定义：</strong>将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。</p>
<p>用来描述部分与整体的关系，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，所以组合模式的使用场景就是出现树形结构的地方。比如：树形菜单，文件目录等树形结构数据的操作</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol>
<li>高层模块调用简单</li>
<li>节点自由增加</li>
</ol>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则</p>
<h4 id="模式代码实现"><a href="#模式代码实现" class="headerlink" title="模式代码实现"></a>模式代码实现</h4><p><strong>源码地址：<a href="https://github.com/mingyuHub/design-patterns" target="_blank" rel="noopener">https://github.com/mingyuHub/design-patterns</a></strong></p>
<h5 id="菜单类"><a href="#菜单类" class="headerlink" title="菜单类"></a>菜单类</h5><p>每个一级菜单有子菜单，二级子菜单有三级菜单，以此形成一个树形结构</p>
<pre><code class="java">/**
 * @author: chenmingyu
 * @date: 2019/3/12 17:46
 * @description:
 */
@Data
public class Menu {

    /**
     * 菜单名
     */
    private String name;

    /**
     * 路径
     */
    private String path;

    private List&lt;Menu&gt; menus;

    public Menu(String name, String path) {
        this.name = name;
        this.path = path;
        menus = new ArrayList&lt;&gt;();
    }

    public void add(Menu menu){
        menus.add(menu);
    }

    public void remove(Menu menu){
        menus.remove(menu);
    }
}</code></pre>
<h5 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h5><pre><code class="java">public static void main(String[] args) {
    Menu home = new Menu(&quot;首页&quot;,&quot;/&quot;);
    Menu tag = new Menu(&quot;标签&quot;,&quot;/标签&quot;);
    Menu archive = new Menu(&quot;归档&quot;,&quot;/归档&quot;);
    Menu menu1 = new Menu(&quot;子菜单1&quot;,&quot;/子菜单1&quot;);
    Menu menu2 = new Menu(&quot;子菜单2&quot;,&quot;/子菜单2&quot;);
    home.add(tag);
    home.add(archive);
    tag.add(menu1);
    archive.add(menu2);
    home.getMenus().forEach(menu -&gt;{
        System.out.println(menu);
    });
}</code></pre>
<p>输出</p>
<pre><code class="java">Menu(name=标签, path=/标签, menus=[Menu(name=子菜单1, path=/子菜单1, menus=[])])
Menu(name=归档, path=/归档, menus=[Menu(name=子菜单2, path=/子菜单2, menus=[])])</code></pre>
<p><strong>参考：</strong>设计模式之禅：<a href="https://www.kancloud.cn/sstd521/design/193581" target="_blank" rel="noopener">https://www.kancloud.cn/sstd521/design/193581</a></p>
<p><strong>推荐阅读：</strong><a href="https://chenmingyu.top/design/">23种设计模式详解</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://chenmingyu.top/design-composite/" data-id="ckdn6w7ya0014aktw10nq7wg6" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/" rel="tag">组合模式</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-design-bridge" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/design-bridge/" class="article-date">
  <time datetime="2019-03-05T08:13:12.000Z" itemprop="datePublished">2019-03-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/design-bridge/">23种设计模式之桥接模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h3><p>桥接模式属于结构型模式</p>
<p><strong>定义：</strong> 将抽象和实现解耦，使得两者可以独立地变化</p>
<p>桥接模式是为了解决继承的缺点而提出的设计模式，将系统各维度抽象出来，各维度独立变化，之后可通过聚合，将各维度组合起来，减少它们之间耦合</p>
<h4 id="模式类图"><a href="#模式类图" class="headerlink" title="模式类图"></a>模式类图</h4><p>以游戏为例，游戏可以按品牌分为任天堂游戏和腾讯游戏两种，显示器可以分为CRT，LCD显示器</p>
<p><img src="design-bridge/uml.png" alt=""></p>
<p>​    将游戏和显示器分为两个维度，当两个维度都可以独立变化时，使用聚合将各维度组合，这时如果要增加一个游戏或者显示器，只需要增加相应子类就可以</p>
<h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ol>
<li>桥接模式主要作用就是解耦，解决多重继承导致的问题，将抽象和实现的分离</li>
<li>优秀的扩展能力，想扩展就增加实现</li>
<li>通过抽象层进行聚合完成封装，实现细节对客户透明</li>
</ol>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><p>会增加系统的理解与设计难度</p>
<h4 id="模式代码实现"><a href="#模式代码实现" class="headerlink" title="模式代码实现"></a>模式代码实现</h4><p><strong>源码地址：<a href="https://github.com/mingyuHub/design-patterns" target="_blank" rel="noopener">https://github.com/mingyuHub/design-patterns</a></strong></p>
<h5 id="抽象游戏类"><a href="#抽象游戏类" class="headerlink" title="抽象游戏类"></a>抽象游戏类</h5><p><code>AbstractGame</code>，按游戏分类</p>
<pre><code class="java">/**
 * @author: chenmingyu
 * @date: 2019/3/11 17:13
 * @description: 抽象游戏类
 */
public abstract class AbstractGame {

    protected AbstractDisplayer displayer;

    public void setAbstractDisplayer(AbstractDisplayer displayer) {
        this.displayer = displayer;
    }

    /**
     * 玩游戏
     */
    public abstract void play();
}</code></pre>
<h5 id="具体游戏实现"><a href="#具体游戏实现" class="headerlink" title="具体游戏实现"></a>具体游戏实现</h5><p>任天堂游戏</p>
<pre><code class="java">/**
 * @author: chenmingyu
 * @date: 2019/3/11 17:17
 * @description: 任天堂游戏
 */
public class NintendoGame extends AbstractGame{

    @Override
    public void play() {
        System.out.println(&quot;启动任天堂游戏&quot;);
        displayer.run();
    }
}</code></pre>
<p>腾讯游戏</p>
<pre><code class="java">/**
 * @author: chenmingyu
 * @date: 2019/3/11 17:21
 * @description:
 */
public class TencentGame extends AbstractGame {

    @Override
    public void play() {
        System.out.println(&quot;启动腾讯游戏&quot;);
        displayer.run();
    }
}</code></pre>
<h5 id="抽象显示器类"><a href="#抽象显示器类" class="headerlink" title="抽象显示器类"></a>抽象显示器类</h5><p><code>AbstractDisplayer</code> 按显示器分类</p>
<pre><code class="java">/**
 * @author: chenmingyu
 * @date: 2019/3/11 17:25
 * @description: 抽象显示器
 */
public abstract class AbstractDisplayer {

    /**
     * 运行
     */
    public abstract void run();
}</code></pre>
<p>LCD显示器</p>
<pre><code class="java">/**
 * @author: chenmingyu
 * @date: 2019/3/11 17:27
 * @description: LCD显示器
 */
public class LCDDisplay extends AbstractDisplayer{

    @Override
    public void run() {
        System.out.println(&quot;运行 LCD显示器&quot;);
    }
}</code></pre>
<p>CRT显示器</p>
<pre><code class="java">/**
 * @author: chenmingyu
 * @date: 2019/3/11 17:28
 * @description: CRT显示器
 */
public class CRTDisplayer extends AbstractDisplayer {

    @Override
    public void run() {
        System.out.println(&quot;运行 CRT显示器&quot;);
    }
}</code></pre>
<h5 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h5><p>通过聚合实现不同游戏使用不同那个的显示器玩</p>
<pre><code class="java">public static void main(String[] args) {

    AbstractGame nintendoGame = new NintendoGame();
    nintendoGame.setAbstractDisplayer(new LCDDisplay());
    nintendoGame.play();
    AbstractGame tencentGame = new TencentGame();
    tencentGame.setAbstractDisplayer(new CRTDisplayer());
    tencentGame.play();
}</code></pre>
<p>输出</p>
<pre><code class="java">启动任天堂游戏
运行彩色显示器
启动腾讯游戏
运行老式黑白显示器</code></pre>
<p>桥接模式使用了类间的聚合关系、继承、覆写等常用功能，但是它却提供了一个非常清晰、稳定的架构。</p>
<p><strong>参考：</strong></p>
<p>​    设计模式之禅：<a href="https://www.kancloud.cn/sstd521/design/193620" target="_blank" rel="noopener">https://www.kancloud.cn/sstd521/design/193620</a></p>
<p>​    桥接模式|菜鸟教程：<a href="http://www.runoob.com/design-pattern/bridge-pattern.html" target="_blank" rel="noopener">http://www.runoob.com/design-pattern/bridge-pattern.html</a></p>
<p><strong>推荐阅读：</strong><a href="https://chenmingyu.top/design/">23种设计模式详解</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://chenmingyu.top/design-bridge/" data-id="ckdn6w7xf000iaktw5ms4h6fw" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/" rel="tag">桥接模式</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-design-builder" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/design-builder/" class="article-date">
  <time datetime="2019-03-04T07:24:04.000Z" itemprop="datePublished">2019-03-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/design-builder/">23种设计模式之建造者模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h3><p>建造者模式属于创建型设计模式，用来组装复杂的实例</p>
<p><strong>定义：</strong>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示</p>
<p>建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。</p>
<h4 id="模式类图"><a href="#模式类图" class="headerlink" title="模式类图"></a>模式类图</h4><p><img src="design-builder/uml.png" alt=""></p>
<p><strong>角色</strong></p>
<ol>
<li>抽象建造者：Builder，目的是为了将建造的具体过程交给它的子类来实现。这样更容易扩展。一般至少会有两个抽象方法，一个用来建造产品，一个是用来返回产品</li>
<li>具体的建造者： ConcreteBuilder，实现抽象建造者的所有未实现的方法，具体来说一般是两项任务：组建产品；返回组建好的产品</li>
<li>产品类：Product，一般是一个较为复杂的对象</li>
<li>管理类：Director，负责调用适当的建造者来组建产品，被用来封装程序中易变的部分</li>
</ol>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol>
<li><p>客户端不必知道产品内部组成的细节，封装性好</p>
</li>
<li><p>建造者独立，容易扩展</p>
</li>
</ol>
<h4 id="模式代码实现"><a href="#模式代码实现" class="headerlink" title="模式代码实现"></a>模式代码实现</h4><p><strong>源码地址：<a href="https://github.com/mingyuHub/design-patterns" target="_blank" rel="noopener">https://github.com/mingyuHub/design-patterns</a></strong></p>
<p>以电脑为例，电脑拥有cpu，内存，硬盘，涉及的类：<code>Builder(抽象建造者)</code>，<code>ConcreteBuilder(具体的建造者)</code>，<code>Computer(产品类)</code>，<code>Director(管理类)</code></p>
<h5 id="抽象建造者"><a href="#抽象建造者" class="headerlink" title="抽象建造者"></a>抽象建造者</h5><pre><code class="java">/**
 * @author: chenmingyu
 * @date: 2019/3/4 17:05
 * @description: 抽象建造者
 */
public abstract class Builder {

    /**
     * 组装cpu
     */
    public abstract void builderCpu(String cpu);

    /**
     * 组装内存
     */
    public abstract void builderMemory(String memory);

    /**
     * 组装硬盘
     */
    public abstract void builderDisk(String disk);

    /**
     * 获取电脑
     * @return
     */
    public abstract Computer getComputer();

}</code></pre>
<h5 id="具体的建造者"><a href="#具体的建造者" class="headerlink" title="具体的建造者"></a>具体的建造者</h5><pre><code class="java">/**
 * @author: chenmingyu
 * @date: 2019/3/4 17:14
 * @description: 具体的建造者
 */
public class ConcreteBuilder extends Builder {

    private Computer computer = new Computer();

    @Override
    public void builderCpu(String cpu) {
        computer.setCpu(cpu);
    }

    @Override
    public void builderMemory(String memory) {
        computer.setMemory(memory);
    }

    @Override
    public void builderDisk(String disk) {
        computer.setDisk(disk);
    }

    @Override
    public Computer getComputer() {
        return computer;
    }
}</code></pre>
<h5 id="产品类"><a href="#产品类" class="headerlink" title="产品类"></a>产品类</h5><pre><code class="java">/**
 * @author: chenmingyu
 * @date: 2019/3/4 16:57
 * @description: 电脑产品
 */
@Data
public class Computer {

    private String cpu;

    private String memory;

    private String disk;

}</code></pre>
<h5 id="主管类"><a href="#主管类" class="headerlink" title="主管类"></a>主管类</h5><pre><code class="java">/**
 * @author: chenmingyu
 * @date: 2019/3/4 17:10
 * @description: 主管类
 */
public class Director {

    private Builder builder = new ConcreteBuilder();

    /**
     * 组装电脑
     */
    public Computer builderComputer(String cpu, String memory, String disk){
        builder.builderCpu(cpu);
        builder.builderMemory(memory);
        builder.builderDisk(disk);
        return builder.getComputer();
    }
}</code></pre>
<h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><pre><code class="java">public static void main(String[] args) {
    Director director = new Director();
    Computer computer = director.builderComputer(&quot;Intel cpu&quot;,&quot;内存&quot;,&quot;硬盘&quot;);
    System.out.println(computer);
}</code></pre>
<h5 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h5><pre><code class="java">Computer(cpu=Intel cpu, memory=内存, disk=硬盘)</code></pre>
<p>建造者模式与工程方法模式的不同在于建造者模式关注的是零件类型和装配工艺（顺序）</p>
<p>建造者模式还有种更常见的使用方式：</p>
<p>使用静态内部类</p>
<pre><code class="java">public class Cache {

    private final String name;

    private final String condition;

    protected Cache(Builder b) {
        this.name = b.name;
        this.condition = b.condition;
    }

    public String getName() {
        return name;
    }

    public String getCondition() {
        return condition;
    }

    public static class Builder {

        private String name = &quot;&quot;;
        private String condition = &quot;&quot;;

        public Builder setName(String name) {
            this.name = name;
            return this;
        }

        public Builder setCondition(String condition) {
            this.condition = condition;
            return this;
        }

        public Cache build(){
            return new Cache(this);
        };
    }
}</code></pre>
<p>使用时：</p>
<pre><code class="java">new Cache.Builder().setName(&quot;cmy&quot;).setCondition(&quot;condition&quot;).build()；</code></pre>
<p><strong>推荐阅读：</strong><a href="https://chenmingyu.top/design/">23种设计模式详解</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://chenmingyu.top/design-builder/" data-id="ckdn6w7xq000oaktwb7vx38o7" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/" rel="tag">建造者模式</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-springboot-async" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/springboot-async/" class="article-date">
  <time datetime="2019-03-01T09:13:35.000Z" itemprop="datePublished">2019-03-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/springboot-async/">spring Boot 2.x | 异步调用，定时任务</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h4><p>在springboot中实现定时任务很简单</p>
<p>1，启动类上增加一个<code>@EnableScheduling</code>注解</p>
<pre><code class="java">@EnableScheduling
@SpringBootApplication
public class SpringbootAsyncApplication {

    public static void main(String[] args) {
        SpringApplication.run(SpringbootAsyncApplication.class, args);
    }

}</code></pre>
<p>2，创建一个定时任务类，使用<code>@Scheduled</code>注解</p>
<pre><code class="java">/**
 * @author: chenmingyu
 * @date: 2019/3/1 17:33
 * @description: 定时任务
 */
@Component
public class Schedule {

    @Scheduled(cron = &quot;0/1 * * * * ?&quot;)
    public void test() {
        System.out.println(&quot;...测试...&quot;);
    }
}</code></pre>
<p>启动后，输出如下</p>
<p><img src="E:%5Cmy%5Cmyblog%5Csource_posts%5Cspringboot-async%5C%E8%BE%93%E5%87%BA.png" alt=""></p>
<h4 id="异步调用"><a href="#异步调用" class="headerlink" title="异步调用"></a>异步调用</h4><p>异步调用，指的是一个可以无需等待被调用方法的返回值就让操作继续进行的方法</p>
<p>springboot中实现异步调用</p>
<p>1，启动类上增加一个<code>@EnableAsync</code>注解</p>
<pre><code class="java">@EnableAsync
@SpringBootApplication
public class SpringbootAsyncApplication {

    public static void main(String[] args) {
        SpringApplication.run(SpringbootAsyncApplication.class, args);
    }

}</code></pre>
<p>2，使用<code>@async</code>注解</p>
<pre><code class="java">/**
 * @author: chenmingyu
 * @date: 2019/3/1 17:49
 * @description: 异步调用
 */
@Component
public class UserTest {

    @Async
    public void testOne() throws Exception{
        System.out.println(&quot;testOne 开始执行&quot;);
        Thread.sleep(2000L);
        System.out.println(&quot;testOne 执行结束&quot;);
    }

    @Async
    public void testTwo() throws Exception{
        System.out.println(&quot;testTwo 开始执行&quot;);
        Thread.sleep(1000L);
        System.out.println(&quot;testTwo 执行结束&quot;);
    }
}</code></pre>
<p>测试</p>
<pre><code class="java">@RunWith(SpringRunner.class)
@SpringBootTest
public class SpringbootAsyncApplicationTests {

    @Autowired
    private UserTest userTest;

    @Test
    public void contextLoads() throws Exception{
        userTest.testOne();
        userTest.testTwo();
        //防止主线程执行完
        Thread.sleep(5000L);
    }
}</code></pre>
<p>输出</p>
<p><img src="springboot-async/async.png" alt=""></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://chenmingyu.top/springboot-async/" data-id="ckdn6w811004paktwdju70q4e" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/springboot/" rel="tag">springboot</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/" rel="tag">定时任务</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8/" rel="tag">异步调用</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-design-facade" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/design-facade/" class="article-date">
  <time datetime="2019-03-01T06:30:21.000Z" itemprop="datePublished">2019-03-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/design-facade/">23种设计模式之外观模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h3><p>外观模式属于结构型设计模式</p>
<p><strong>定义：</strong>要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行。提供一个高层次的接口，使得子系统更易于使用</p>
<p>外观模式是为了解决类与类之间的责任关系和依赖关系的，通过提供一个Facade类来隐藏这些复杂的类之间关系的调用，并提供一个接口，供外部调用，利用这种方式进行类之间的解耦</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol>
<li>减少类之间依赖，只对Facade类进行依赖，对Facade类里的复杂的类没有关联</li>
<li>提高了灵活性，只对Facade类进行依赖，Facade类内部可自由变化</li>
<li>提高安全性，只能对Facade类进行访问，无法访问到Facade类里复杂的类</li>
</ol>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>不符合开闭原则，如果Facade类设计不好，后期无法通过对Facade类重写覆盖去解决问题，只能改代码</p>
<h4 id="模式代码实现"><a href="#模式代码实现" class="headerlink" title="模式代码实现"></a>模式代码实现</h4><p><strong>源码地址：<a href="https://github.com/mingyuHub/design-patterns" target="_blank" rel="noopener">https://github.com/mingyuHub/design-patterns</a></strong></p>
<p>以汽车启动为例，需要启动引擎，仪表盘，大灯等，有可能需要先启动引擎之后才可以启动仪表盘，或者大灯的启动依赖引擎的启动等，这个时候就需要一个Facade类来隐藏这些复杂的依赖关系</p>
<p>实例涉及的类：<code>Engine（引擎）</code>，<code>Armaturenbrett（仪表盘）</code>，<code>Headlight（大灯）</code>，<code>Car（汽车类，facade类）</code></p>
<h5 id="Engine"><a href="#Engine" class="headerlink" title="Engine"></a>Engine</h5><pre><code class="java">/**
 * @author: chenmingyu
 * @date: 2019/3/1 14:53
 * @description: 引擎
 */
public class Engine {

    public void start(){
        System.out.println(&quot;启动引擎...&quot;);
    }
}</code></pre>
<h5 id="Armaturenbrett"><a href="#Armaturenbrett" class="headerlink" title="Armaturenbrett"></a>Armaturenbrett</h5><pre><code class="java">/**
 * @author: chenmingyu
 * @date: 2019/3/1 15:02
 * @description: 仪表盘
 */
public class Armaturenbrett {

    public void start(){
        System.out.println(&quot;启动仪表盘...&quot;);
    }
}</code></pre>
<h5 id="Headlight"><a href="#Headlight" class="headerlink" title="Headlight"></a>Headlight</h5><pre><code class="java">/**
 * @author: chenmingyu
 * @date: 2019/3/1 14:53
 * @description:
 */
public class Headlight {

    public void start(){
        System.out.println(&quot;启动大灯...&quot;);
    }
}</code></pre>
<h5 id="Facade类"><a href="#Facade类" class="headerlink" title="Facade类"></a>Facade类</h5><p>Car</p>
<pre><code class="java">/**
 * @author: chenmingyu
 * @date: 2019/3/1 14:57
 * @description:
 */
public class Car {

    /**
     * 发动机
     */
    private Engine engine;
    /**
     * 仪表盘
     */
    private Armaturenbrett armaturenbrett;
    /**
     * 大灯
     */
    private Headlight headlight;

    public Car() {
        this.engine = new Engine();
        this.armaturenbrett = new Armaturenbrett();
        this.headlight = new Headlight();
    }

    public void start(){
        System.out.println(&quot;启动汽车...&quot;);
        engine.start();
        armaturenbrett.start();
        headlight.start();
        System.out.println(&quot;汽车以启动...&quot;);
    }
}</code></pre>
<h5 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h5><pre><code class="java">public static void main(String[] args) {
    Car car = new Car();
    car.start();
}</code></pre>
<p>输出</p>
<pre><code class="java">启动汽车...
启动引擎...
启动仪表盘...
启动大灯...
汽车以启动...</code></pre>
<p><code>Car</code>类封装了启动引擎，仪表盘，大灯等操作，客户端只需要调用<code>car</code>类的<code>start()</code>方法即可启动上述组件，而不用去对实例化每个类然后去调用其<code>start()</code>，利用这种方式进行解耦。</p>
<p><strong>参考：</strong>设计模式之禅：<a href="https://www.kancloud.cn/sstd521/design/193593" target="_blank" rel="noopener">https://www.kancloud.cn/sstd521/design/193593</a></p>
<p><strong>推荐阅读：</strong><a href="https://chenmingyu.top/design/">23种设计模式详解</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://chenmingyu.top/design-facade/" data-id="ckdn6w7y80010aktw2gbt0ywo" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/" rel="tag">外观模式</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-design-proxy" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/design-proxy/" class="article-date">
  <time datetime="2019-03-01T05:59:35.000Z" itemprop="datePublished">2019-03-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/design-proxy/">23种设计模式之代理模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>代理模式属于结构型模式</p>
<p><strong>定义：</strong>为其他对象提供一种代理以控制对这个对象的访问</p>
<p>代理模式就是在操作原对象的时候，多出来一个代理类，用来对原对象的访问进行控制和替代原对象进行一些操作</p>
<h4 id="模式类图"><a href="#模式类图" class="headerlink" title="模式类图"></a>模式类图</h4><p><img src="design-proxy/uml.png" alt=""></p>
<p><strong>角色</strong></p>
<ol>
<li>抽象接口：<code>able</code>，定义业务接口</li>
<li>被代理类：<code>Source</code></li>
<li>代理类：<code>Proxy</code>，用来对原对象的访问进行控制和替代原对象进行一些操作</li>
<li>客户端：<code>Client</code>，负责调用代理类</li>
</ol>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol>
<li>职责清晰，被代理类只关心实际的业务逻辑，不关心其他事情</li>
<li>高扩展性，被代理类可以随意更改，不会影响到代理类对其的访问控制</li>
</ol>
<h4 id="模式代码实现"><a href="#模式代码实现" class="headerlink" title="模式代码实现"></a>模式代码实现</h4><p><strong>源码地址：<a href="https://github.com/mingyuHub/design-patterns" target="_blank" rel="noopener">https://github.com/mingyuHub/design-patterns</a></strong></p>
<p>以打电话为例</p>
<h5 id="抽象接口"><a href="#抽象接口" class="headerlink" title="抽象接口"></a>抽象接口</h5><p>被代理类和代理类都实现此接口</p>
<pre><code class="java">/**
 * @author: chenmingyu
 * @date: 2019/3/1 10:20
 * @description: 手机接口
 */
public interface Phoneable {

    /**
     * 打电话
     */
    void call();
}</code></pre>
<h5 id="被代理类"><a href="#被代理类" class="headerlink" title="被代理类"></a>被代理类</h5><p>实现Phoneable接口</p>
<pre><code class="java">/**
 * @author: chenmingyu
 * @date: 2019/3/1 10:19
 * @description: 被代理类
 */
public class Phone implements Phoneable {

    @Override
    public void call() {
        System.out.println(&quot;打电话&quot;);
    }
}</code></pre>
<h5 id="代理类"><a href="#代理类" class="headerlink" title="代理类"></a>代理类</h5><p>实现Phoneable接口，持有被代理类实例，提供validate()对被代理类的访问进行控制</p>
<pre><code class="java">/**
 * @author: chenmingyu
 * @date: 2019/3/1 14:16
 * @description: 代理类
 */
public class Proxy implements Phoneable {

    private Phone phone = new Phone();

    @Override
    public void call() {
        if(validate()){
            phone.call();
        }
        System.out.println(&quot;结束通话&quot;);
    }

    /**
     * 检查手机号
     * @return
     */
    private Boolean validate(){
        System.out.println(&quot;手机号验证通过&quot;);
        return Boolean.TRUE;
    }
}</code></pre>
<h5 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h5><pre><code class="java">public static void main(String[] args) {
    Proxy proxy = new Proxy();
    proxy.call();
}</code></pre>
<p>输出</p>
<pre><code class="java">手机号验证通过
打电话
结束通话</code></pre>
<p>代理模式与装饰器模式的区别，代理模式主要是对原对象的访问进行控制，而装饰器模式主要是为了对原对象增加新的功能</p>
<p><strong>参考：</strong>设计模式之禅：<a href="https://www.kancloud.cn/sstd521/design/193540" target="_blank" rel="noopener">https://www.kancloud.cn/sstd521/design/193540</a></p>
<p><strong>推荐阅读：</strong><a href="https://chenmingyu.top/design/">23种设计模式详解</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://chenmingyu.top/design-proxy/" data-id="ckdn6w7z1001vaktw33h6ceno" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/" rel="tag">代理模式</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-design-decorator" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/design-decorator/" class="article-date">
  <time datetime="2019-03-01T02:35:31.000Z" itemprop="datePublished">2019-03-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/design-decorator/">23种设计模式之装饰器模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h3><p>装饰器模式属于结构型模式</p>
<p><strong>定义：</strong>动态地给一个对象添加一些额外的职责。就增加功能来说，装饰模式相比生成子类更为灵活</p>
<p>装饰器模式可以为一个现有的类增加新功能，又不改变其结构，要求装饰类和被装饰类实现同一个接口，装饰类持有被装饰类的实例</p>
<h4 id="模式类图"><a href="#模式类图" class="headerlink" title="模式类图"></a>模式类图</h4><p><img src="design-decorator/uml.png" alt=""></p>
<p><strong>角色</strong></p>
<ol>
<li>抽象接口：<code>able</code>接口,最核心组件，被装饰类和装饰类都实现此接口</li>
<li>被装饰类：<code>Source</code>，要被装饰的类</li>
<li>装饰类：<code>Decorator</code>，持有<code>Source</code>类实例，装饰<code>Source</code>类，为<code>Source</code>类动态添加新功能</li>
</ol>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>装饰类和被装饰类相互解耦</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>多层的装饰比较复杂，减少装饰类的数量，可以降低系统的复杂度</p>
<h4 id="模式代码实现"><a href="#模式代码实现" class="headerlink" title="模式代码实现"></a>模式代码实现</h4><p><strong>源码地址：<a href="https://github.com/mingyuHub/design-patterns" target="_blank" rel="noopener">https://github.com/mingyuHub/design-patterns</a></strong></p>
<p>以打电话为例，涉及<code>Phoneable</code>（接口），<code>Phone</code>（被装饰类），<code>Decorator</code>（装饰类）</p>
<h5 id="抽象接口"><a href="#抽象接口" class="headerlink" title="抽象接口"></a>抽象接口</h5><p>被装饰类和装饰类都实现此接口</p>
<pre><code class="java">/**
 * @author: chenmingyu
 * @date: 2019/3/1 10:20
 * @description: 手机接口
 */
public interface Phoneable {

    /**
     * 打电话
     */
    void call();
}</code></pre>
<h5 id="被装饰类"><a href="#被装饰类" class="headerlink" title="被装饰类"></a>被装饰类</h5><p>实现Phoneable接口</p>
<pre><code class="java">/**
 * @author: chenmingyu
 * @date: 2019/3/1 10:19
 * @description: 被装饰类
 */
public class Phone implements Phoneable{

    @Override
    public void call() {
        System.out.println(&quot;打电话&quot;);
    }
}</code></pre>
<h5 id="装饰类"><a href="#装饰类" class="headerlink" title="装饰类"></a>装饰类</h5><p>实现Phoneable接口，持有被装饰类实例</p>
<pre><code class="java">/**
 * @author: chenmingyu
 * @date: 2019/3/1 10:26
 * @description: 装饰类
 */
public class Decorator implements Phoneable{

   private Phone phone;

   public Decorator(Phone phone) {
       this.phone = phone;
   }

    @Override
    public void call() {
        System.out.println(&quot;装饰器模式 前置功能：打电话先拨号&quot;);
        phone.call();
        System.out.println(&quot;装饰器模式 后置功能：挂断电话&quot;);
    }
}</code></pre>
<h5 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h5><pre><code class="java">public static void main(String[] args) {
    Decorator decorator = new Decorator(new Phone());
    decorator.call();
}</code></pre>
<p>输出</p>
<pre><code class="java">装饰器模式 前置功能：打电话先拨号
打电话
装饰器模式 后置功能：挂断电话</code></pre>
<p>当我们要拓展一个类的功能时，可以选择使用集成或者装饰器模式，继承的实现是静态，而装饰器模式实现的是动态的，装饰器模式的缺点是会产生很多功能类似的类</p>
<p><strong>参考：</strong>设计模式之禅：<a href="https://www.kancloud.cn/sstd521/design/193565" target="_blank" rel="noopener">https://www.kancloud.cn/sstd521/design/193565</a></p>
<p><strong>推荐阅读：</strong><a href="https://chenmingyu.top/design/">23种设计模式详解</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://chenmingyu.top/design-decorator/" data-id="ckdn6w7y6000waktw8m680rhk" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/" rel="tag">装饰器模式</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-design" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/design/" class="article-date">
  <time datetime="2019-02-28T08:15:27.000Z" itemprop="datePublished">2019-02-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/design/">设计模式详解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><blockquote>
<p>学习设计模式不是一蹴而就的事情，需要长时间的积累，在平时写代码的时候多思考，学习设计模式的时候也不要死记硬背，要了解每个设计模式都解决了那些问题，另外就是最好要记住每种设计模式的类图，这样对于实操写代码的时候很有帮助    </p>
</blockquote>
<p>设计模式是软件设计中的最佳实践，是由前人的知识和经验总结而来，是针对不同特定场景问题的解决方案，通过学习设计模式，可以让我们知道在什么情况下应该使用什么设计模式，也可以增加我们对于软件设计的理解，设计出更稳定，扩展性更好的系统</p>
<p>设计模式总共包括6大设计原则和23种设计模式，23种设计模式又分为创建型模式，结构型模式，行为型模式三种，每种模式解决的问题也不相同，创建型设计模式主要关注与如何创建对象；结构型设计模式主要关注于类和对象之间的关系；而行为型设计模式关注于对象之间的通信；</p>
<h2 id="23种设计模式"><a href="#23种设计模式" class="headerlink" title="23种设计模式"></a>23种设计模式</h2><p>每种设计模式都以定义，类图，角色，优缺点，示例的方式进行讲解</p>
<p><strong>源码地址：<a href="https://github.com/mingyuHub/design-patterns" target="_blank" rel="noopener">https://github.com/mingyuHub/design-patterns</a></strong></p>
<p>各模式之间关联：</p>
<p><img src="design/the-relationship-between-design-patterns.jpg" alt=""></p>
<h3 id="创建型设计模式"><a href="#创建型设计模式" class="headerlink" title="创建型设计模式"></a>创建型设计模式</h3><p><strong>关注于如何创建对象</strong></p>
<h5 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a><a href="https://chenmingyu.top/design-singleton/">单例模式</a></h5><p>保证在程序运行期间一个类只有一个实例，并提供一个全局访问点</p>
<h5 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a><a href="https://chenmingyu.top/design-factory-method/">工厂模式</a></h5><p>用工厂方法代替new操作，让子类去决定实例化哪个类，工厂方法将一个类的实例化延迟到子类</p>
<h5 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a><a href="https://chenmingyu.top/design-abstract-factory/">抽象工厂</a></h5><p>抽象工厂模式属于创建型模式，是对工厂方法模式的扩展，抽象工厂比工厂模式更为抽象，工厂方法模式针对产品等级结构，而抽象工厂针对产品族</p>
<h5 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a><a href="https://chenmingyu.top/design-builder/">建造者模式</a></h5><p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示</p>
<h5 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a><a href="https://chenmingyu.top/design-phototype/">原型模式</a></h5><p>通过克隆一个已经存在的对象实例来返回新的实例，而不是通过new去创建对象</p>
<h3 id="结构型设计模式"><a href="#结构型设计模式" class="headerlink" title="结构型设计模式"></a>结构型设计模式</h3><p><strong>关注于类和对象之间的关系</strong></p>
<h5 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a><a href="https://chenmingyu.top/design-adapter/">适配器模式</a></h5><p>组合两个不相干类，在两个不兼容的接口之间提供一个混合接口，使其兼容适配</p>
<h5 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a><a href="https://chenmingyu.top/design-bridge/">桥接模式</a></h5><p>将抽象部分与它的实现部分分离，使它们都可以独立地变化。桥接模式将系统各维度抽象出来，各维度独立变化，之后可通过聚合，将各维度组合起来，减少它们之间耦合</p>
<h5 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a><a href="https://chenmingyu.top/design-composite/">组合模式</a></h5><p>用来描述部分与整体的关系，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，所以组合模式的使用场景就是出现树形结构的地方。</p>
<h5 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a><a href="https://chenmingyu.top/design-decorator/">装饰器模式</a></h5><p>装饰器模式可以为一个现有的类增加新功能，又不改变其结构，要求装饰类和被装饰类实现同一个接口，装饰类持有被装饰类的实例</p>
<h5 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a><a href="https://chenmingyu.top/design-facade/">外观模式</a></h5><p>外观模式是为了解决类与类之家的责任关系和依赖关系的，通过提供一个Facade类来隐藏这些复杂的类之间关系的调用，并提供一个接口，供外部调用，利用这种方式进行类之间的解耦</p>
<h5 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a><a href="https://chenmingyu.top/design-proxy/">代理模式</a></h5><p>代理模式就是在操作原对象的时候，多出来一个代理类，用来对原对象的访问进行控制和替代原对象进行一些操作</p>
<h5 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a><a href="https://chenmingyu.top/design-flyweight/">享元模式</a></h5><p>运用共享技术有效地支持大量细粒度对象的复用，主要用来减少对象的创建，用来减少内存和提高性能，比较常见的连接池，缓冲池这类的池技术都是享元模式</p>
<h3 id="行为型设计模式"><a href="#行为型设计模式" class="headerlink" title="行为型设计模式"></a>行为型设计模式</h3><p><strong>关注于对象之间的通信</strong></p>
<h5 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a><a href="https://chenmingyu.top/design-template-method/">模板方法模式</a></h5><p>在父类（抽象类）中定义好算法的流程，提供抽象方法，针对不同的实现交由不同的子类去实现，通过这种方式将公共代码提取出来封装在父类中，然后父类去控制行为，子类负责实现</p>
<h5 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a><a href="https://chenmingyu.top/design-strategy/">策略模式</a></h5><p>在系统中提供一组策略，并将每个策略封装成类，使他们可以相互转换，具体策略的选择由客户端决定</p>
<h5 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a><a href="https://chenmingyu.top/design-observer/">观察者模式</a></h5><p>定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新</p>
<h5 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a><a href="https://chenmingyu.top/design-iterator/">迭代器模式</a></h5><p>迭代器模式就是为解决遍历元素而诞生的，它提供一种方法访问一个容器对象中各个元素，而又不需暴露该对象的内部细节</p>
<h5 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a><a href="https://chenmingyu.top/design-chain/">责任链模式</a></h5><p>使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止</p>
<h5 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a><a href="https://chenmingyu.top/design-command/">命令模式</a></h5><p>将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能，用来降低类之间解耦</p>
<h5 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a><a href="https://chenmingyu.top/design-memento/">备忘录模式</a></h5><p>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态，其实就是在某个时刻备份了对象的状态，在更改对象状态后，可以通过备份将对象还原成备份时刻的状态</p>
<h5 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a><a href="https://chenmingyu.top/design-state/">状态模式</a></h5><p>允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类，对象的行为依赖于它的状态（属性），并且可以根据它的状态改变而改变它的相关行为</p>
<h5 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a><a href="https://chenmingyu.top/design-visitor/">访问者模式</a></h5><p>封装一些作用于某种数据结构中的各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作，访问者模式就是将数据结构与数据操作相分离</p>
<h5 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a><a href="https://chenmingyu.top/design-mediator/">中介者模式</a></h5><p>用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互</p>
<h5 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a><a href="https://chenmingyu.top/design-interpreter/">解释器模式</a></h5><p>给定一门语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子</p>
<h3 id="六大原则"><a href="#六大原则" class="headerlink" title="六大原则"></a>六大原则</h3><h4 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h4><p>单一职责要求的是类和接口职责单一，不能存在多于一个导致类变更的原因</p>
<h4 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h4><p>对扩展开放，对修改关闭，在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果</p>
<h4 id="里氏代换原则"><a href="#里氏代换原则" class="headerlink" title="里氏代换原则"></a>里氏代换原则</h4><p>里氏代换原则是面向对象设计的基本原则之一，氏代换原则中说，任何父类可以出现的地方，子类一定可以出现。子类对父类的方法尽量不要重写和重载。因为父类代表了定义好的结构，通过这个规范的接口与外界交互，子类不应该随便破坏它</p>
<h4 id="依赖倒转原则"><a href="#依赖倒转原则" class="headerlink" title="依赖倒转原则"></a>依赖倒转原则</h4><p>这个是开闭原则的基础，具体内容：面向接口编程，依赖于抽象而不依赖于具体。写代码时用到具体类时，不与具体类交互，而与具体类的上层接口交互</p>
<h4 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h4><p>这个的意思每个接口的职责应该是单一的，接口中不应该存在子类用不到的方法，如若不然，就需要将接口拆分为多个接口</p>
<h4 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h4><p>迪米特法则又叫最少知道原则，一个类对自己依赖的类知道的越少越好。也就是说无论被依赖的类多么复杂，都应该将逻辑封装在方法的内部，通过public方法提供给外部。这样当被依赖的类变化时，才能最小的影响该类</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://chenmingyu.top/design/" data-id="ckdn6w7zf002haktwe6qwg9xl" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/3/">&amp;laquo; 上一页</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/5/">下一页 &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/elasticsearch/">elasticsearch</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/jvm/">jvm</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/mysql/">mysql</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/nosql/">nosql</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/tomcat/">tomcat</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/zookeeper/">zookeeper</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/">分布式事务</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">并发编程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%88%AC%E8%99%AB/">爬虫</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/">网络协议</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Integer%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/" rel="tag">Integer缓存机制</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/aop/" rel="tag">aop</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/effective/" rel="tag">effective</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/elasticsearch/" rel="tag">elasticsearch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/email/" rel="tag">email</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/exception/" rel="tag">exception</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gc/" rel="tag">gc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/htmlunit/" rel="tag">htmlunit</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/io/" rel="tag">io</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jvm%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/" rel="tag">jvm内存区域</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mybatis/" rel="tag">mybatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nio/" rel="tag">nio</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/rabbitmq/" rel="tag">rabbitmq</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/" rel="tag">redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/springboot/" rel="tag">springboot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring%E6%BA%90%E7%A0%81/" rel="tag">spring源码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/swagger2/" rel="tag">swagger2</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/thymeleaf/" rel="tag">thymeleaf</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tomcat/" rel="tag">tomcat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/zookeeper/" rel="tag">zookeeper</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/" rel="tag">中介者模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/" rel="tag">二分查找</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" rel="tag">二叉树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/" rel="tag">享元模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/" rel="tag">代理模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/" rel="tag">分布式事务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" rel="tag">单例模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/" rel="tag">原型模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8F%8D%E5%B0%84/" rel="tag">反射</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/" rel="tag">命令模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/" rel="tag">垃圾收集器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/" rel="tag">备忘录模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/" rel="tag">外观模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/" rel="tag">定时任务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/" rel="tag">工厂模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/" rel="tag">建造者模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BC%82%E5%B8%B8/" rel="tag">异常</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8/" rel="tag">异步调用</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/" rel="tag">抽象工厂</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/" rel="tag">日志管理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/" rel="tag">桥接模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/" rel="tag">模板方法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/" rel="tag">策略模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" rel="tag">类加载机制</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B4%A2%E5%BC%95/" rel="tag">索引</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BA%BF%E7%A8%8B/" rel="tag">线程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/" rel="tag">线程池</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/" rel="tag">组合模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/" rel="tag">网络协议</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/" rel="tag">装饰器模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/" rel="tag">观察者模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/" rel="tag">解释器模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/" rel="tag">访问者模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/" rel="tag">责任链模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/" rel="tag">迭代器模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/" rel="tag">适配器模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/" rel="tag">配置文件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%94%81/" rel="tag">锁</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9B%86%E5%90%88/" rel="tag">集合</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Integer%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/" style="font-size: 10px;">Integer缓存机制</a> <a href="/tags/aop/" style="font-size: 10px;">aop</a> <a href="/tags/effective/" style="font-size: 10px;">effective</a> <a href="/tags/elasticsearch/" style="font-size: 12.5px;">elasticsearch</a> <a href="/tags/email/" style="font-size: 10px;">email</a> <a href="/tags/exception/" style="font-size: 10px;">exception</a> <a href="/tags/gc/" style="font-size: 10px;">gc</a> <a href="/tags/htmlunit/" style="font-size: 10px;">htmlunit</a> <a href="/tags/io/" style="font-size: 10px;">io</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/jvm%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/" style="font-size: 10px;">jvm内存区域</a> <a href="/tags/mybatis/" style="font-size: 12.5px;">mybatis</a> <a href="/tags/mysql/" style="font-size: 12.5px;">mysql</a> <a href="/tags/nio/" style="font-size: 10px;">nio</a> <a href="/tags/rabbitmq/" style="font-size: 10px;">rabbitmq</a> <a href="/tags/redis/" style="font-size: 17.5px;">redis</a> <a href="/tags/springboot/" style="font-size: 20px;">springboot</a> <a href="/tags/spring%E6%BA%90%E7%A0%81/" style="font-size: 10px;">spring源码</a> <a href="/tags/swagger2/" style="font-size: 10px;">swagger2</a> <a href="/tags/thymeleaf/" style="font-size: 10px;">thymeleaf</a> <a href="/tags/tomcat/" style="font-size: 10px;">tomcat</a> <a href="/tags/zookeeper/" style="font-size: 10px;">zookeeper</a> <a href="/tags/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">中介者模式</a> <a href="/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/" style="font-size: 10px;">二分查找</a> <a href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" style="font-size: 10px;">二叉树</a> <a href="/tags/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">享元模式</a> <a href="/tags/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">代理模式</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/" style="font-size: 10px;">分布式事务</a> <a href="/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">单例模式</a> <a href="/tags/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">原型模式</a> <a href="/tags/%E5%8F%8D%E5%B0%84/" style="font-size: 10px;">反射</a> <a href="/tags/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">命令模式</a> <a href="/tags/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/" style="font-size: 10px;">垃圾收集器</a> <a href="/tags/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/" style="font-size: 12.5px;">备忘录模式</a> <a href="/tags/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">外观模式</a> <a href="/tags/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/" style="font-size: 10px;">定时任务</a> <a href="/tags/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">工厂模式</a> <a href="/tags/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">建造者模式</a> <a href="/tags/%E5%BC%82%E5%B8%B8/" style="font-size: 10px;">异常</a> <a href="/tags/%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8/" style="font-size: 10px;">异步调用</a> <a href="/tags/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/" style="font-size: 10px;">抽象工厂</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 15px;">数据结构</a> <a href="/tags/%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/" style="font-size: 10px;">日志管理</a> <a href="/tags/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">桥接模式</a> <a href="/tags/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/" style="font-size: 10px;">模板方法</a> <a href="/tags/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">策略模式</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 12.5px;">算法</a> <a href="/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" style="font-size: 10px;">类加载机制</a> <a href="/tags/%E7%B4%A2%E5%BC%95/" style="font-size: 10px;">索引</a> <a href="/tags/%E7%BA%BF%E7%A8%8B/" style="font-size: 10px;">线程</a> <a href="/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/" style="font-size: 10px;">线程池</a> <a href="/tags/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">组合模式</a> <a href="/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/" style="font-size: 10px;">网络协议</a> <a href="/tags/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">装饰器模式</a> <a href="/tags/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">观察者模式</a> <a href="/tags/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">解释器模式</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">设计模式</a> <a href="/tags/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">访问者模式</a> <a href="/tags/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">责任链模式</a> <a href="/tags/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">迭代器模式</a> <a href="/tags/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">适配器模式</a> <a href="/tags/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/" style="font-size: 10px;">配置文件</a> <a href="/tags/%E9%94%81/" style="font-size: 10px;">锁</a> <a href="/tags/%E9%9B%86%E5%90%88/" style="font-size: 10px;">集合</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">七月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">十二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">十月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">九月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">八月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">七月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">六月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">十二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/mysql-create-index/">这道面试题你确定不看看吗：一条sql语句，有多个查询条件，你会选择哪个字段作为索引，为什么？</a>
          </li>
        
          <li>
            <a href="/zookeeper/">zookeeper命令详解</a>
          </li>
        
          <li>
            <a href="/data-structure-binary-search/">【数据结构】| 二分查找</a>
          </li>
        
          <li>
            <a href="/jvm-class-loader/">【jvm】类加载机制</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 陈明羽<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>