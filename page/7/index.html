

<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8"/>
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="renderer" content="webkit">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-status-bar-style" content="black">
	<meta name="description" content="但行好事 莫问前程">

	
		
			<link rel="stylesheet" href="/bower_components/fancybox/source/jquery.fancybox.css">
		
		<link rel="stylesheet" href="/bower_components/font-awesome/css/font-awesome.min.css">
		<link rel="stylesheet" href="/css/style.css">
	

	<title>但行好事 莫问前程 - 明羽</title>
<meta name="generator" content="Hexo 4.2.1"></head>
<body>
<header id="header">
	<div class="center">
		<div class="wrap">
			<div id="site">
				<h1>
					<a href="/">但行好事 莫问前程</a>
					
						<a class="github" href="https://github.com/dnxbf321" target="_blank" rel="noopener">
	  					<svg aria-hidden="true" class="octicon octicon-mark-github" height="28" role="img" version="1.1" viewBox="0 0 16 16" width="28"><path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59 0.4 0.07 0.55-0.17 0.55-0.38 0-0.19-0.01-0.82-0.01-1.49-2.01 0.37-2.53-0.49-2.69-0.94-0.09-0.23-0.48-0.94-0.82-1.13-0.28-0.15-0.68-0.52-0.01-0.53 0.63-0.01 1.08 0.58 1.23 0.82 0.72 1.21 1.87 0.87 2.33 0.66 0.07-0.52 0.28-0.87 0.51-1.07-1.78-0.2-3.64-0.89-3.64-3.95 0-0.87 0.31-1.59 0.82-2.15-0.08-0.2-0.36-1.02 0.08-2.12 0 0 0.67-0.21 2.2 0.82 0.64-0.18 1.32-0.27 2-0.27 0.68 0 1.36 0.09 2 0.27 1.53-1.04 2.2-0.82 2.2-0.82 0.44 1.1 0.16 1.92 0.08 2.12 0.51 0.56 0.82 1.27 0.82 2.15 0 3.07-1.87 3.75-3.65 3.95 0.29 0.25 0.54 0.73 0.54 1.48 0 1.07-0.01 1.93-0.01 2.2 0 0.21 0.15 0.46 0.55 0.38C13.71 14.53 16 11.53 16 8 16 3.58 12.42 0 8 0z"></path></svg>
						</a>
					
				</h1>
				
					<h2>
						<a href="/">明羽</a>
					</h2>
				
			</div>
			<nav id="menu">
				<ul>
					
						<li><a href="/">首页</a></li>
					
						<li><a href="/archives/">归档</a></li>
					
				</ul>
			</nav>
		</div>
	</div>
</header>

<div id="content">
	<div class="center">
		<div class="main-col">
			

	
		
		<article class="post">
	<div class="post-content">
		<header>
			
				<div class="meta">
					<div class="icon">
						
							<i class="fa fa-file"></i>
						
					</div>
					<time datetime="2019-02-13T08:20:42.000Z">2019-02-13</time>
				</div>
			
			
	
		<h1 class="title" data-role="articleTitle"><a href="/design-template-method/">23种设计模式之模板方法</a></h1>
	

		</header>
		<div class="entry">
			
				<h4 id="模板方法"><a href="#模板方法" class="headerlink" title="模板方法"></a>模板方法</h4><p>模板方法属于行为型模式</p>
<p><strong>定义：</strong>定义一个操作中的算法的框架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p>
<p>在父类（抽象类）中定义好算法的流程，提供抽象方法，针对不同的实现交由不同的子类去实现，通过这种方式将公共代码提取出来封装在父类中，然后父类去控制行为，子类负责实现，这样当有很多子类的时候，如果要修改算法，只需要在父类中更改算法的行为</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol>
<li>封装不变部分，扩展可变部分</li>
<li>提取公共部分代码，便于维护</li>
<li>行为由父类控制，子类实现</li>
</ol>
<h4 id="模式代码实现"><a href="#模式代码实现" class="headerlink" title="模式代码实现"></a>模式代码实现</h4><p><strong>源码地址：<a href="https://github.com/mingyuHub/design-patterns" target="_blank" rel="noopener">https://github.com/mingyuHub/design-patterns</a></strong></p>
<p>已支付为例，涉及AbstractPay，BankCardPay，WeChatPay三个类。</p>
<h5 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h5><p><code>AbstractPay</code>，定义了三个抽象方法和一个控制支付流程的方法，也就是模板方法，这个方法使用final修饰，防止被重写</p>
<pre><code class="java">/**
 * @auther: chenmingyu
 * @date: 2019/2/13 16:58
 * @description: 抽象类，定义支付流程
 */
public abstract class AbstractPay {

    /**
     * 获取支付信息
     */
    abstract String getPayInfo();

    /**
     * 执行支付
     */
    abstract void executePay();

    /**
     * 支付反馈信息
     */
    abstract void payMessage();

    /**
     * 支付
     */
    public final void pay(){
        String info = getPayInfo();
        System.out.println(&quot;支付账户:&quot;+info);
        executePay();
        payMessage();
    }
}</code></pre>
<h5 id="子类BankCardPay"><a href="#子类BankCardPay" class="headerlink" title="子类BankCardPay"></a>子类BankCardPay</h5><p><code>BankCardPay</code>，提供银行卡支付，继承AbstractPay类重写三个抽象方法，提供银行卡支付的实现</p>
<pre><code class="java">/**
 * @auther: chenmingyu
 * @date: 2019/2/13 17:18
 * @description: 银行卡支付
 */
public class BankCardPay extends AbstractPay{

    @Override
    String getPayInfo() {
        return &quot;我的银行卡信息&quot;;
    }

    @Override
    void executePay() {
        System.out.println(&quot;银行卡支付了&quot;);
    }

    @Override
    void payMessage() {
        System.out.println(&quot;银行卡方式支付，发短息&quot;);
    }
}</code></pre>
<h5 id="子类WeChatPay"><a href="#子类WeChatPay" class="headerlink" title="子类WeChatPay"></a>子类WeChatPay</h5><p><code>WeChatPay</code>提供微信支付，继承AbstractPay类重写三个抽象方法，提供微信支付的实现</p>
<pre><code class="java">/**
 * @auther: chenmingyu
 * @date: 2019/2/13 17:20
 * @description: 微信支付
 */
public class WeChatPay extends AbstractPay{

    @Override
    String getPayInfo() {
        return &quot;我的微信支付信息&quot;;
    }

    @Override
    void executePay() {
        System.out.println(&quot;微信支付了&quot;);
    }

    @Override
    void payMessage() {
        System.out.println(&quot;微信方式支付，微信内发服务通知&quot;);
    }
}</code></pre>
<h5 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h5><pre><code class="java">public static void main(String[] args) {
    BankCardPay bankCardPay = new BankCardPay();
    bankCardPay.pay();
    System.out.println(&quot;... 分割线 ...&quot;);
    WeChatPay weChatPay = new WeChatPay();
    weChatPay.pay();
}</code></pre>
<p>输出</p>
<pre><code class="java">支付账户:我的银行卡信息
银行卡支付了
银行卡方式支付，发短息
... 分割线 ...
支付账户:我的微信支付信息
微信支付了
微信方式支付，微信内发服务通知</code></pre>
<p>抽象类封装了一个final类型的方法，方法中调用其他的抽象方法，制定业务流程骨架，抽象方法交由子类去实现。当有多个子类实现逻辑相同时，建议使用模板方法实现</p>
<p><strong>参考：</strong>设计模式之禅：<a href="https://www.kancloud.cn/sstd521/design/193531" target="_blank" rel="noopener">https://www.kancloud.cn/sstd521/design/193531</a></p>
<p><strong>推荐阅读：</strong><a href="https://chenmingyu.top/design/">23种设计模式详解</a></p>

			
		</div>
		<footer class="clearfix">
			
				
				
					<div class="disqus-comment">
						<i class="fa fa-comment"></i><a href="https://chenmingyu.top/design-template-method/#disqus_thread" class="comment-link"> 评论</a>
					</div>
				
			
			
	<div class="categories">
		<i class="fa fa-folder"></i>
		
			<a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
		
	</div>

			
	<div class="tags">
		<i class="fa fa-tags"></i>
		
			<a href="/tags/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/">#模板方法</a>
		
	</div>

		</footer>
	</div>
</article>
	
		
		<article class="post">
	<div class="post-content">
		<header>
			
				<div class="meta">
					<div class="icon">
						
							<i class="fa fa-file"></i>
						
					</div>
					<time datetime="2019-02-03T07:05:46.000Z">2019-02-03</time>
				</div>
			
			
	
		<h1 class="title" data-role="articleTitle"><a href="/design-singleton/">23种设计模式之单例模式</a></h1>
	

		</header>
		<div class="entry">
			
				<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>单例模式属于创建型模式</p>
<p><strong>定义：</strong>确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例</p>
<p>单例模式目的是保证在程序运行期间一个类只有一个实例，并提供一个全局访问点，无论什么情况下，只会生成一个实例，免去繁琐的创建销毁对象的过程。</p>
<h3 id="模式类图"><a href="#模式类图" class="headerlink" title="模式类图"></a>模式类图</h3><p><img src="/design-singleton/uml.png" alt></p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li>减少了内存开支，避免频繁地创建、销毁对象</li>
<li>避免对资源的多重占用</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化</p>
<h4 id="如何设计单例"><a href="#如何设计单例" class="headerlink" title="如何设计单例"></a>如何设计单例</h4><p>如何设计单例模式其实很简单，只需要考虑一个问题，实例是否可以保证是全局唯一</p>
<p>关于实例是否保证是全局唯一延伸出的问题：</p>
<ol>
<li>是否线程安全，不安全肯定就不能保证全局只有一个实例</li>
<li>是否支持序列化，支持序列化的类，被反序列化之后肯定就不是全局唯一了</li>
<li>是否支持反射，支持反射肯定也不是全局唯一的</li>
<li>是否可以被克隆，这个也不能保证全局唯一</li>
</ol>
<p>所以设计一个安全的单例需要考虑的问题还是很多的。</p>
<p>针对上述问题常见的解决办法：</p>
<ol>
<li>保证线程安全，使用volatile+synchronized实现</li>
<li>防止序列化攻击，重写readResolve方法</li>
<li>防止反射，常用的方案是在单例类里增加一个boolean类型的flag标识，在实例化的时候先判断flag标识</li>
<li>防止克隆，重写clone()方法</li>
</ol>
<p>实现一个最简单的单例就需要考虑到以上的所有问题，这个时候什么有用的方法还没写那，代码就已经很多了，那有没有简单的办法既满足上述条件，代码又简洁那，那肯定有，使用枚举实现单例。</p>
<h3 id="常见的单例模式实现"><a href="#常见的单例模式实现" class="headerlink" title="常见的单例模式实现"></a>常见的单例模式实现</h3><p>常见的单例模式实现方案大概有五种，懒汉模式，饿汉模式，双重检查方式实现，静态内部类实现，枚举实现</p>
<p>分个类：</p>
<ol>
<li>是否支持延迟加载，分为懒汉模式和饿汉模式</li>
<li>线程安全设计了双重检查模式实现，静态内部类实现方式</li>
<li>不支持序列化，反射，克隆，枚举实现方式</li>
</ol>
<p>其中懒汉模式，饿汉模式，双重检查方式实现，静态内部类的实现方式都可以概括为以下两步：</p>
<ol>
<li>构造函数私有化，保证在外部无法new对象</li>
<li>提供一个static方法获取当前实例（不同方案，实现不同）</li>
</ol>
<p>当然枚举的实现方式最简单，也最安全的，所以推荐使用枚举实现，其次推荐使用静态内部类方式实现。</p>
<h5 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h5><p>不是延迟加载，加载类的时候直接初始化</p>
<pre><code class="java">/**
 * @auther: chenmingyu
 * @date: 2019/2/12 16:26
 * @description:
 */
public class Singleton {

    private static Singleton singleton = new Singleton();

    private Singleton() {
    }

    public static Singleton getInstance(){
        return singleton;
    }
}</code></pre>
<p>优点：线程安全，代码简单。</p>
<p>缺点：不是延迟加载，如果你用不到这个类，它也会实例化，还有一个问题就是如果这个实例依赖外部一些配置文件，参数什么的，在实例化之前就要获取到，否则就实例化异常</p>
<h5 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h5><p>延迟加载，首次需要使用的时候在实例化，需要考虑线程安全</p>
<p>线程不安全的实现方式</p>
<pre><code class="java">public class Singleton {

    private static Singleton singleton;

    private Singleton() {
    }

    public static Singleton getInstance(){
        if(null == singleton){
            singleton = new Singleton();
        }
        return singleton;
    }
}</code></pre>
<h5 id="双重检查（DCL：Double-Check-Lock）"><a href="#双重检查（DCL：Double-Check-Lock）" class="headerlink" title="双重检查（DCL：Double Check Lock）"></a>双重检查（DCL：Double Check Lock）</h5><p>线程安全的实现方式：</p>
<pre><code class="java">public class Singleton {

    private static volatile Singleton singleton;

    private Singleton() {
    }

    public static Singleton getInstance(){
        if(null == singleton){
            synchronized (Singleton.class){
                if(null == singleton){
                    singleton = new Singleton();
                }
            }
        }
        return singleton;
    }
}</code></pre>
<p>面试官：为什么使用volatile修饰singleton变量？</p>
<ol>
<li>说的volatile，首先肯定回答volatile的可见性</li>
<li>防止重排序优化，如果不用volatile修饰，多线程的情况下，可能会出现线程A进入synchronized代码块，执行new Singleton();，首先给singleton分配内存，但是还没有初始化变量，这时候线程B进入getInstance方法，进行第一个判断，此时singleton已经不为空，直接返回singleton，然后肯定报错。使用volatile修饰之后禁止jvm重排序优化，所以就不会出现上面的问题</li>
</ol>
<h5 id="静态内部类实现"><a href="#静态内部类实现" class="headerlink" title="静态内部类实现"></a>静态内部类实现</h5><p>使用静态内部类实现也是延迟加载，利用静态内部类去实现线程安全，只有在第一次调用getInstance方法的时候才会去加载SingletonHolder，初始化SINGLETON</p>
<pre><code class="java">public class Singleton {

    private Singleton() {
    }

    public static Singleton getInstance(){
        return SingletonHolder.SINGLETON;
    }

    private static class SingletonHolder{
        private static final Singleton SINGLETON = new Singleton();
    }
}</code></pre>
<h5 id="枚举实现"><a href="#枚举实现" class="headerlink" title="枚举实现"></a>枚举实现</h5><p>枚举实现代码更简洁，线程安全，并且保证枚举不会被反序列化，反射和克隆</p>
<pre><code class="java">/**
 * @auther: chenmingyu
 * @date: 2019/2/12 16:30
 * @description:
 */
public enum Singleton {

    SINGLETON;

    /**
     * 提供的方法
     */
    public void method(){
        System.out.println(&quot;枚举实现&quot;);
    }
}</code></pre>
<p><strong>推荐阅读：</strong><a href="https://chenmingyu.top/design/">23种设计模式详解</a></p>

			
		</div>
		<footer class="clearfix">
			
				
				
					<div class="disqus-comment">
						<i class="fa fa-comment"></i><a href="https://chenmingyu.top/design-singleton/#disqus_thread" class="comment-link"> 评论</a>
					</div>
				
			
			
	<div class="categories">
		<i class="fa fa-folder"></i>
		
			<a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
		
	</div>

			
	<div class="tags">
		<i class="fa fa-tags"></i>
		
			<a href="/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/">#单例模式</a>
		
	</div>

		</footer>
	</div>
</article>
	
		
		<article class="post">
	<div class="post-content">
		<header>
			
				<div class="meta">
					<div class="icon">
						
							<i class="fa fa-file"></i>
						
					</div>
					<time datetime="2019-01-18T06:14:10.000Z">2019-01-18</time>
				</div>
			
			
	
		<h1 class="title" data-role="articleTitle"><a href="/effective-note-one/">effective java（第二版）读书笔记</a></h1>
	

		</header>
		<div class="entry">
			
				<blockquote>
<p>effective java（第二版）读书笔记</p>
<p>在这本书里讲解了在Java编程中78条极具实用价值的经验规则，虽然是jdk是1.5的，但是其中的每条经验规则都值得我们去学习</p>
</blockquote>
<h3 id="创建和销毁对象"><a href="#创建和销毁对象" class="headerlink" title="创建和销毁对象"></a>创建和销毁对象</h3><h4 id="考虑使用静态工厂方法代替构造器"><a href="#考虑使用静态工厂方法代替构造器" class="headerlink" title="考虑使用静态工厂方法代替构造器"></a>考虑使用静态工厂方法代替构造器</h4><h5 id="优势："><a href="#优势：" class="headerlink" title="优势："></a>优势：</h5><ul>
<li><p>静态工厂方法有名称</p>
</li>
<li><p>在使用静态工厂的时候，针对经常重复请求创建相同的对象可以使用预先创建好的对象，避免重复创建，进而极大的提升性能，比如Boolean.valueOf(boolean b)；</p>
</li>
<li><p>可以返回类型的任何子类型的对象</p>
</li>
<li><p>在创建参数化类型实例的时候，使代码更加简洁</p>
</li>
</ul>
<h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><ul>
<li>类如果没有公有的构造器，将不能被子类化</li>
</ul>
<p>解决办法就是：一个类要么为继承而设计，并提供文档说明，要么就禁止集成</p>
<h4 id="遇到多个构造器参数时考虑使用构建器"><a href="#遇到多个构造器参数时考虑使用构建器" class="headerlink" title="遇到多个构造器参数时考虑使用构建器"></a>遇到多个构造器参数时考虑使用构建器</h4><h5 id="重叠构造器"><a href="#重叠构造器" class="headerlink" title="重叠构造器"></a>重叠构造器</h5><p>​    提供一个必要参数的构造器，然后第二个构造器有一个可选参数，然后而第二构造器有两个可选参数，以此类推，调用的时候就调用最少参数的构造方法去实例化；</p>
<pre><code class="java">public Article(String title) {
    this(title,&quot;默认作者&quot;);
}

public Article(String title, String author) {
    this.title = title;
    this.author = author;
}</code></pre>
<p>使用重叠构造器不是不可以，但是当参数太多的时候，就会失去控制，代码变得繁重。</p>
<h5 id="javaBeans模式"><a href="#javaBeans模式" class="headerlink" title="javaBeans模式"></a>javaBeans模式</h5><p>​    利用无参的构造方法new一个对象，然后set属性的值</p>
<pre><code class="java">public static void main(String[] args) {
        Author author = new Author();
        author.setName(&quot;陈明羽&quot;);
        author.setAddress(&quot;北京&quot;);
}</code></pre>
<h5 id="Builder模式"><a href="#Builder模式" class="headerlink" title="Builder模式"></a>Builder模式</h5><p>​    builder模式模拟了具有名称的可选参数，这种方式可以有多个可变参数，可以利用方法进行复制，代码更易于阅读和编写，而且十分灵活。</p>
<pre><code class="java">/**
 * @auther: chenmingyu
 * @date: 2019/1/20 16:30
 * @description:
 */
public class Address {

    private Integer firstCode;

    private String firstName;

    private Integer secondCode;

    private String secondName;

    public static class Builder{

        private Integer firstCode;

        private String firstName;

        private Integer secondCode;

        private String secondName;

        public Builder(Integer firstCode, Integer secondCode) {
            this.firstCode = firstCode;
            this.secondCode = secondCode;
        }

        public Builder firstName(String firstName){
            this.firstName =firstName;
            return this;
        }

        public Builder secondName(String secondName){
            this.secondName =secondName;
            return this;
        }

        public Address builder(){
            return new Address(this);
        }
    }

    public Address(Builder builder) {
        this.firstCode = builder.firstCode;
        this.firstName = builder.firstName;
        this.secondCode = builder.secondCode;
        this.secondName = builder.secondName;
    }

    @Override
    public String toString() {
        return &quot;Address{&quot; +
                &quot;firstCode=&quot; + firstCode +
                &quot;, firstName=&#39;&quot; + firstName + &#39;\&#39;&#39; +
                &quot;, secondCode=&quot; + secondCode +
                &quot;, secondName=&#39;&quot; + secondName + &#39;\&#39;&#39; +
                &#39;}&#39;;
    }

    public static void main(String[] args) {
        Address address = new Address.Builder(1,2).firstName(&quot;北京&quot;).secondName(&quot;丰台&quot;).builder();
        System.out.println(address.toString());
    }
}</code></pre>
<h4 id="使用私有构造器或者枚举类型强化singleton属性"><a href="#使用私有构造器或者枚举类型强化singleton属性" class="headerlink" title="使用私有构造器或者枚举类型强化singleton属性"></a>使用私有构造器或者枚举类型强化singleton属性</h4><p>如何写单例：</p>
<p>使用枚举实现单例</p>
<h4 id="通过私有构造器强化不可实例化的能力"><a href="#通过私有构造器强化不可实例化的能力" class="headerlink" title="通过私有构造器强化不可实例化的能力"></a>通过私有构造器强化不可实例化的能力</h4><p>这个就是如果你写的这类不想被实例化，就将构造方法private化</p>
<h4 id="避免创建不必要的对象"><a href="#避免创建不必要的对象" class="headerlink" title="避免创建不必要的对象"></a>避免创建不必要的对象</h4><p>能用工厂获取对象的或者重复使用的对象就不要自己新new一个对象</p>
<h4 id="避免使用终结方法"><a href="#避免使用终结方法" class="headerlink" title="避免使用终结方法"></a>避免使用终结方法</h4><h3 id="对于所有对象都通用的方法"><a href="#对于所有对象都通用的方法" class="headerlink" title="对于所有对象都通用的方法"></a>对于所有对象都通用的方法</h3><h4 id="覆盖equals时请遵守通用约定"><a href="#覆盖equals时请遵守通用约定" class="headerlink" title="覆盖equals时请遵守通用约定"></a>覆盖equals时请遵守通用约定</h4><p>覆盖equals方法是遵守通用原则</p>
<ul>
<li><p>自反省：对于非null的引用值x，x.equals(x)必须返回true</p>
<p>(对于任何非null的引用值x，x.equals(null)必须返回false)；</p>
</li>
<li><p>对称性：x.equals(y)为true则y.equals(x)为true；</p>
</li>
<li><p>传递性：x.equals(y)为true，y.equals(z)为true则x.equals(z)为true；</p>
</li>
<li><p>一致性：多次调用结果一致；</p>
<p>重写equals方法的时候一定要按照上面四个特性检查一下</p>
</li>
</ul>
<h4 id="覆盖equals时总要覆盖hashCode"><a href="#覆盖equals时总要覆盖hashCode" class="headerlink" title="覆盖equals时总要覆盖hashCode"></a>覆盖equals时总要覆盖hashCode</h4><p>​    重写equals的时候一定要重写hashCode，否则所有跟hash有关的操作都可能会出现错误。</p>
<h4 id="始终要覆盖toString"><a href="#始终要覆盖toString" class="headerlink" title="始终要覆盖toString"></a>始终要覆盖toString</h4><p> 提供好的toString可以使类使用起来更舒适，尤其当对象比较大的时候 ，调用toString时应该返回一个摘要信息，像system.out.println的实现都依赖于toString方法。所以一个好的toString方法应该是对当前类的描述，而不是所有属性结构。</p>
<h4 id="谨慎的覆盖clone"><a href="#谨慎的覆盖clone" class="headerlink" title="谨慎的覆盖clone"></a>谨慎的覆盖clone</h4><p>克隆</p>
<h5 id="考虑实现comparable接口"><a href="#考虑实现comparable接口" class="headerlink" title="考虑实现comparable接口"></a>考虑实现comparable接口</h5><p>排序</p>
<h3 id="类和接口"><a href="#类和接口" class="headerlink" title="类和接口"></a>类和接口</h3><h4 id="使类和成员的可访问性最小化"><a href="#使类和成员的可访问性最小化" class="headerlink" title="使类和成员的可访问性最小化"></a>使类和成员的可访问性最小化</h4><p>一个方法如过被声明成private或者protected，一旦被Override之后，如过要再想改的话，就要考虑一下，就像是牵一发而动全身，而一个方法被声明为private，当你要改的时候就好弄了，想怎么改就怎么改</p>
<p>所以就要尽可能的使每个类成员或方法的可访问性最小化，尽量不被外界访问</p>
<p>java的访问级别</p>
<ul>
<li>private  自己用的</li>
<li>package-private</li>
<li>protected 想让子类用的</li>
<li>public 对外提供的</li>
</ul>
<h4 id="在公有类中使用访问方法而非共有域"><a href="#在公有类中使用访问方法而非共有域" class="headerlink" title="在公有类中使用访问方法而非共有域"></a>在公有类中使用访问方法而非共有域</h4><p>这条啥意思那，就是访问类的变量的时候都使用提供的公共方法，像类的变量都用private修饰，然后提供get/set方法来访问变量</p>
<h4 id="使可变性最小化"><a href="#使可变性最小化" class="headerlink" title="使可变性最小化"></a>使可变性最小化</h4><p>不可变类是指在类的实例不会改变，从实例被创建开始，实例所包含的所有的信息在其声明周期内不再改变。</p>
<p>为了使类变成不可变的类，须遵守的5条规则</p>
<ul>
<li>不提供任何会修改对象状态的方法</li>
<li>保证类不被扩展</li>
<li>所有的域使用final修饰</li>
<li>所有的域都是私有的</li>
<li>确保对于任何可变组件的互斥访问：如果类具有可变对象的域，则必须确保该类的客户端无法获得指向这些对象的引用，并且不要使用客户端提供的对象引用来初始化可变的域</li>
</ul>
<p>优点：</p>
<h4 id="复合优于继承"><a href="#复合优于继承" class="headerlink" title="复合优于继承"></a>复合优于继承</h4><h4 id="要么为继承而设计，并提供文档说明，要么就禁止集成"><a href="#要么为继承而设计，并提供文档说明，要么就禁止集成" class="headerlink" title="要么为继承而设计，并提供文档说明，要么就禁止集成"></a>要么为继承而设计，并提供文档说明，要么就禁止集成</h4><h6 id="为继承而设计，并提供文档说明"><a href="#为继承而设计，并提供文档说明" class="headerlink" title="为继承而设计，并提供文档说明"></a>为继承而设计，并提供文档说明</h6><ul>
<li><p>文档必须说明可覆盖性和方法的自用性</p>
<ul>
<li>在文档注释尾部介绍可覆盖方法内部工作情况和调用其他方法的描述信息，就是对存在自用性的可覆盖方法，应该用文档精确描述调用细节</li>
<li>为继承专门设计的类的唯一的测试方法就是编写子类。经验表明，3个子类通常就足以测试一个可扩展的类。</li>
<li>可覆盖性: 可以被重写的方法</li>
<li>自用性: 父类里可覆盖的方法调用了别的可覆盖的方法<ul>
<li>将可覆盖方法的代码移到一个私有的一个辅助方法，然后可覆盖方法调用这个方法，别的方法也是去调用这个私有的方法</li>
</ul>
</li>
<li>构造器决不能调用可被覆盖的方法,有可能会出错</li>
</ul>
</li>
</ul>
<h6 id="如何禁止继承"><a href="#如何禁止继承" class="headerlink" title="如何禁止继承"></a>如何禁止继承</h6><ul>
<li><p>final 修饰</p>
</li>
<li><p>private 修饰构造函数</p>
</li>
<li><p>提供静态工厂获取对象</p>
</li>
</ul>
<h4 id="接口优于抽象类"><a href="#接口优于抽象类" class="headerlink" title="接口优于抽象类"></a>接口优于抽象类</h4><p>java只允许单继承，多实现</p>
<p>接口允许我们构造非层次结构的类型框架</p>
<p>接口一旦被公开，切被广泛使用，在想修改基本上是不可能的</p>
<p>通过对导出的每个重要接口都提供一个抽象的骨架实现类，把接口和抽象类的优点结合起来（骨架实现类）</p>
<ul>
<li>骨架实现类：如：AbstractSet</li>
</ul>
<h4 id="接口只用于定义类型"><a href="#接口只用于定义类型" class="headerlink" title="接口只用于定义类型"></a>接口只用于定义类型</h4><p>接口是一种规范，可以充当实现类的类型，不应该被用来导出常量</p>
<p>反例：ObjectStreamConstants</p>
<p>如果常量与接口或类密切相关，就应该定义在接口或类中</p>
<h4 id="类层次优于标签类"><a href="#类层次优于标签类" class="headerlink" title="类层次优于标签类"></a>类层次优于标签类</h4><p>标签类</p>
<ul>
<li><p>缺点：过于冗长，可读性，有很多不相关的代码，增加了内存的占用</p>
</li>
<li><p>类层次</p>
<ul>
<li>为每种原始标签类都定义根类的具体子类</li>
<li>类层次的好处：直观反映类型层次之间关系，访问的时候直接访问，而不是通过访问方法</li>
</ul>
</li>
</ul>
<h4 id="用函数对象表示策略"><a href="#用函数对象表示策略" class="headerlink" title="用函数对象表示策略"></a>用函数对象表示策略</h4><p>函数对象：主要用途就是实现策略模式</p>
<h4 id="优先考虑静态成员类"><a href="#优先考虑静态成员类" class="headerlink" title="优先考虑静态成员类"></a>优先考虑静态成员类</h4><p>嵌套类</p>
<ul>
<li>嵌套类有四种：<ul>
<li>静态成员类<ul>
<li>当外部类需要使用内部类，而内部类无需外部类资源，并且内部类可以单独创建的时候</li>
</ul>
</li>
<li>非静态成员类</li>
<li>匿名类</li>
<li>局部类    </li>
</ul>
</li>
<li>静态成员类与非静态成员类的不同：<ul>
<li>静态成员类不需要有指向外部类的引用。但非静态成员类需要持有对外部类的引用</li>
</ul>
</li>
</ul>

			
		</div>
		<footer class="clearfix">
			
				
				
					<div class="disqus-comment">
						<i class="fa fa-comment"></i><a href="https://chenmingyu.top/effective-note-one/#disqus_thread" class="comment-link"> 评论</a>
					</div>
				
			
			
	<div class="categories">
		<i class="fa fa-folder"></i>
		
			<a href="/categories/java/">java</a>
		
	</div>

			
	<div class="tags">
		<i class="fa fa-tags"></i>
		
			<a href="/tags/effective/">#effective</a>
		
	</div>

		</footer>
	</div>
</article>
	
		
		<article class="post">
	<div class="post-content">
		<header>
			
				<div class="meta">
					<div class="icon">
						
							<i class="fa fa-file"></i>
						
					</div>
					<time datetime="2018-12-23T07:05:46.000Z">2018-12-23</time>
				</div>
			
			
	
		<h1 class="title" data-role="articleTitle"><a href="/tomcat-source-code/">tomcat8 源码分析 | 组件及启动过程</a></h1>
	

		</header>
		<div class="entry">
			
				<p><strong>tomcat 8 源码分析 ，本文主要讲解tomcat拥有哪些组件，容器，又是如何启动的</strong></p>
<h4 id="tomcat"><a href="#tomcat" class="headerlink" title="tomcat"></a>tomcat</h4><h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><p>​    Tomcat是Apache 软件基金会（Apache Software Foundation）的Jakarta 项目中的一个核心项目，Tomcat服务器是一个免费的开放源代码的Web 应用服务器，属于轻量级应用服务器。</p>
<h5 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h5><p>首先我们先看一张图</p>
<p><img src="/tomcat-source-code/jiegou.png" alt="jiegou"></p>
<p>看上图总结一下tomcat的组件主要包括:</p>
<ul>
<li><p>server：整个servlet容器，一个tomcat对应一个server，一个server包含多个service</p>
<p>server在tomcat中的实现类是：StandardServer</p>
</li>
<li><p>service： 一个service包含多个connector（接受请求的协议），和一个container（容器）</p>
<p>多个connector共享一个container容器，</p>
<p>service在tomcat中的实现类是：StandardService</p>
</li>
<li><p>connector：链接器，负责处理客户端请求，解析不同协议及io方式</p>
</li>
<li><p>executor：线程池</p>
</li>
<li><p>container：包含engine，host，context，wrapper等组件</p>
</li>
<li><p>engine：servlet引擎，container容器中顶层的容器对象，一个engine可以包含多个host主机</p>
<p>engine在tomcat中的实现类是：StandardEngine</p>
</li>
<li><p>host：engine容器的子容器，一个host对应一个网络域名，一个host包含多个context</p>
<p>host在tomcat中的实现类是：StandardHost</p>
</li>
<li><p>context：host容器的子容器，表示一个web应用</p>
<p>context在tomcat中的实现类是：StandardContext</p>
</li>
<li><p>wrapper：tomcat中最小的容器单元，表示web应用中的servlet</p>
<p>wrapper在tomcat中的实现类是：StandardWrapper</p>
</li>
</ul>
<p>所以tomcat的组件结构大概是这个样子的：</p>
<p><img src="/tomcat-source-code/1.png" alt="jiegou"></p>
<h5 id="生命周期：Lifecycle"><a href="#生命周期：Lifecycle" class="headerlink" title="生命周期：Lifecycle"></a>生命周期：Lifecycle</h5><p>tomcat的启动过程非常规范，使用Lifecycle接口统一管理各组件的生命周期，根据各个组件之间的父子级关系，首先调用init()方法逐级初始化各组件，然后在调用start()的方法进行启动；</p>
<p>Lifecycle接口提供的方法如下，提供了init，start，destory等方法：</p>
<p><img src="/tomcat-source-code/2.png" alt="jiegou"></p>
<p>tomcat中的组件基本都继承了LifecycleMBeanBase类，LifecycleMBeanBase集成LifecycleBase，LifecycleBase实现Lifecycle接口：</p>
<p><img src="/tomcat-source-code/3.png" alt="jiegou"></p>
<p>LifecycleBase重写Lifecycle接口，比如init()方法，在init()方法中调用initInternal()方法，initInternal()方法是抽象方法，具体实现交由各个子类（组件）去实现。如果没有实现initInternal()方法，则调用默认的LifecycleMBeanBase的initInternal方法。</p>
<h5 id="启动过程"><a href="#启动过程" class="headerlink" title="启动过程"></a>启动过程</h5><p>接下来从源码看一下tomcat的启动流程：</p>
<h6 id="bootstrap"><a href="#bootstrap" class="headerlink" title="bootstrap"></a>bootstrap</h6><p>tomcat的入口类为BootStrap的main方法</p>
<p>Bootstrap中main()方法如下,不重要的代码省略了</p>
<pre><code class="java">/**
 * Main method and entry point when starting Tomcat via the provided
 * scripts.
 *
 * @param args Command line arguments to be processed
 */
public static void main(String args[]) {
        .....
        //初始化    
        bootstrap.init();
        .....
        if (command.equals(&quot;startd&quot;)) {
            args[args.length - 1] = &quot;start&quot;;
            //实例化各组件 调用Catalina类的load方法
            daemon.load(args);
            //启动各组件 调用Catalina类的start方法
            daemon.start();
        }
        .....
}</code></pre>
<p>bootstrap.init()的工作是初始化Bootstrap类，包含初始化类加载器</p>
<pre><code class="java">/**
 * Initialize daemon.
 * @throws Exception Fatal initialization error
 */
public void init() throws Exception {
    //初始化类加载
    initClassLoaders();
    ......
    //实例化Catalina类
    Class&lt;?&gt; startupClass = catalinaLoader.loadClass(&quot;org.apache.catalina.startup.Catalina&quot;);
    Object startupInstance = startupClass.getConstructor().newInstance();
       ......
    catalinaDaemon = startupInstance;

}</code></pre>
<h6 id="Catalina"><a href="#Catalina" class="headerlink" title="Catalina"></a>Catalina</h6><p>接着调用刚初始化的Catalina类的实例catalinaDaemon的load()方法，重要的就两点</p>
<pre><code class="java">/**
 * Start a new server instance.
 */
public void load() {
    .....
    // Digester... 实例化组件
    Digester digester = createStartDigester();
    .....加载server.xml......
    file = configFile();
    inputStream = new FileInputStream(file);
    inputSource = new InputSource(file.toURI().toURL().toString());
    ......
    // 初始化sever
    getServer().init();
}</code></pre>
<h6 id="Digester"><a href="#Digester" class="headerlink" title="Digester"></a>Digester</h6><p>Digester是一种将xml转化为java对象的事件驱动型工具，通过读取xml文件，当识别到特定的节点的时候会执行特定的动作，创建java对象或者执行对象的某个方法</p>
<p><img src="/tomcat-source-code/4.png" alt="jiegou"></p>
<p>通过Digester去创建了Catania中的大量初始化工作，具体详见源码：</p>
<pre><code class="java">// 创建server实例
digester.addObjectCreate(&quot;Server&quot;,
                         &quot;org.apache.catalina.core.StandardServer&quot;,
                         &quot;className&quot;);
//创建Executor
digester.addObjectCreate(&quot;Server/Service/Executor&quot;,
                         &quot;org.apache.catalina.core.StandardThreadExecutor&quot;,
                         &quot;className&quot;);
...等等大量初始化工作...</code></pre>
<p>接着讲，getServer().init()方法的作用是初始化Sever，调用LifecycleBase的init()方法，在init方法中调用的是StandardServer类initInternal()方法</p>
<h6 id="StandardServer"><a href="#StandardServer" class="headerlink" title="StandardServer"></a>StandardServer</h6><p>StandardServer类图如下：</p>
<p><img src="/tomcat-source-code/5.png" alt="jiegou"></p>
<p>StandardServer类initInternal()方法：</p>
<pre><code class="java">/**
 * Invoke a pre-startup initialization. This is used to allow connectors
 * to bind to restricted ports under Unix operating environments.
 */
@Override
protected void initInternal() throws LifecycleException {

    super.initInternal();
    ...省略很多，但是主要的在下面...
    // Initialize our defined Services
    for (int i = 0; i &lt; services.length; i++) {
        //调用services的init
        services[i].init();
    }
}</code></pre>
<p>前面的时候讲过一个server初始化多个services；</p>
<h6 id="StandardService"><a href="#StandardService" class="headerlink" title="StandardService"></a>StandardService</h6><p>services[i].init();初始化的是StandardService类，类图如下</p>
<p><img src="/tomcat-source-code/6.png" alt="jiegou"></p>
<p>StandardService的initInternal() 方法的工作是初始化engine组件，初始化线程池，初始化mapperListener，初始化connector</p>
<pre><code class="java">/**
 * Invoke a pre-startup initialization. This is used to allow connectors
 * to bind to restricted ports under Unix operating environments.
 */
@Override
protected void initInternal() throws LifecycleException {

    super.initInternal();
    //初始化engine
    engine.init();
    //初始化线程池
    // Initialize any Executors
    for (Executor executor : findExecutors()) {
        if (executor instanceof JmxEnabled) {
            ((JmxEnabled) executor).setDomain(getDomain());
        }
        executor.init();
    }
    //初始化mapperListener
    // Initialize mapper listener
    mapperListener.init();
    //初始化connector
    connector.init();

}</code></pre>
<p>初始化executor，mapperListener，connector后面再讲其作用，先接初始化engine</p>
<h6 id="StandardEngine"><a href="#StandardEngine" class="headerlink" title="StandardEngine"></a>StandardEngine</h6><p>StandardEngine的类图如下：</p>
<p><img src="/tomcat-source-code/7.png" alt="jiegou"></p>
<p>在StandardEngine的初始化中并没有直接调用host的初始化，而是调用的父类containerBase的initInternal的方法：</p>
<pre><code class="java">//StandardEngine
@Override
protected void initInternal() throws LifecycleException {
    // Ensure that a Realm is present before any attempt is made to start
    // one. This will create the default NullRealm if necessary.
    getRealm();
    super.initInternal();
}
//containerBase
 @Override
 protected void initInternal() throws LifecycleException {
        BlockingQueue&lt;Runnable&gt; startStopQueue = new LinkedBlockingQueue&lt;&gt;();
        startStopExecutor = new ThreadPoolExecutor(
                getStartStopThreadsInternal(),
                getStartStopThreadsInternal(), 10, TimeUnit.SECONDS,
                startStopQueue,
                new StartStopThreadFactory(getName() + &quot;-startStop-&quot;));
        startStopExecutor.allowCoreThreadTimeOut(true);
        super.initInternal();
    }</code></pre>
<p>host的init是在start阶段去做的，所以后面再说</p>
<h6 id="executor"><a href="#executor" class="headerlink" title="executor"></a>executor</h6><p>executor.init();默认调用LifecycleMBeanBase的initInternal方法</p>
<h6 id="mapperListener"><a href="#mapperListener" class="headerlink" title="mapperListener"></a>mapperListener</h6><p>mapperListener.init();也默认调用LifecycleMBeanBase的initInternal方法</p>
<h6 id="connector"><a href="#connector" class="headerlink" title="connector"></a>connector</h6><p>connector的初始化调用Connector类的initInternal方法，主要是new了一个CoyoteAdapter，初始化protocolHandler</p>
<pre><code class="java">@Override
protected void initInternal() throws LifecycleException {

    super.initInternal();

    // 实例化 CoyoteAdapter 适配器
    adapter = new CoyoteAdapter(this);
    protocolHandler.setAdapter(adapter);
    ......
    try {
        //初始化 protocolHandler
        protocolHandler.init();
    } catch (Exception e) {
        throw new LifecycleException(
                sm.getString(&quot;coyoteConnector.protocolHandlerInitializationFailed&quot;), e);
    }
}</code></pre>
<p>ProtocolHandler.init();的实现：</p>
<p><img src="/tomcat-source-code/8.png" alt="jiegou"></p>
<p>AbstractProtocol是调用endpoint的init方法，这个方法中调用bind()</p>
<pre><code class="java">@Override
public void init() throws Exception {
   //初始化endpoint
   endpoint.init();
}
</code></pre>
<p>bind()针对不同的io类型提供了三种的默认实现</p>
<p><img src="/tomcat-source-code/9.png" alt="jiegou"></p>
<p>进入NioEndpoint类的bind()</p>
<pre><code class="java">/**
 * Initialize the endpoint.
 */
@Override
public void bind() throws Exception {
    //使用nio方式监听端口
    if (!getUseInheritedChannel()) {
        serverSock = ServerSocketChannel.open();
        socketProperties.setProperties(serverSock.socket());
        InetSocketAddress addr = (getAddress()!=null?new InetSocketAddress(getAddress(),getPort()):new InetSocketAddress(getPort()));
        serverSock.socket().bind(addr,getAcceptCount());
    } 
    //设置非阻塞
    serverSock.configureBlocking(true); //mimic APR behavior
    ......
    //开启selectorPool
    selectorPool.open();
}</code></pre>
<h5 id="start过程"><a href="#start过程" class="headerlink" title="start过程"></a>start过程</h5><p>tomcat的start阶段与init阶段相似，都是逐层调用，稍有不同的是在于engine，host，context，wrapper的启动方式；</p>
<p>首先回到Bootstrap的main方法中，继续执行Catalina类的start()，在start()方法中调getServer().start();</p>
<p>调用LifecycleBase类的start()方法，在这个方法中调动StandardServer类实现的startInternal()，在这个类中继续调用service的star()方法，以此类推逐层start调用，直到调用engine的start()，我们看下engine的start()方法，在看下StandardEngine的类图:</p>
<p><img src="/tomcat-source-code/7.png" alt="jiegou"></p>
<p>StandardEngine的startInternal()调用ContainerBase的startInternal()</p>
<pre><code class="java">/**
 * Start this component and implement the requirements
 * of {@link org.apache.catalina.util.LifecycleBase#startInternal()}.
 *
 * @exception LifecycleException if this component detects a fatal error
 *  that prevents this component from being used
 */
@Override
protected synchronized void startInternal() throws LifecycleException {

     ......
    // Start our child containers, if any
    Container children[] = findChildren();
    List&lt;Future&lt;Void&gt;&gt; results = new ArrayList&lt;&gt;();
    for (int i = 0; i &lt; children.length; i++) {
        results.add(startStopExecutor.submit(new StartChild(children[i])));
    }
    ......
}</code></pre>
<p>findChildren()的方法找到的是engine容器的子容器然后在new StartChild(children[i])中调用子类容器的start()；使用这种方式依次启动子容器</p>

			
		</div>
		<footer class="clearfix">
			
				
				
					<div class="disqus-comment">
						<i class="fa fa-comment"></i><a href="https://chenmingyu.top/tomcat-source-code/#disqus_thread" class="comment-link"> 评论</a>
					</div>
				
			
			
	<div class="categories">
		<i class="fa fa-folder"></i>
		
			<a href="/categories/tomcat/">tomcat</a>
		
	</div>

			
	<div class="tags">
		<i class="fa fa-tags"></i>
		
			<a href="/tags/tomcat/">#tomcat</a>
		
	</div>

		</footer>
	</div>
</article>
	
		
		<article class="post">
	<div class="post-content">
		<header>
			
				<div class="meta">
					<div class="icon">
						
							<i class="fa fa-file"></i>
						
					</div>
					<time datetime="2018-12-06T07:41:01.000Z">2018-12-06</time>
				</div>
			
			
	
		<h1 class="title" data-role="articleTitle"><a href="/springboot-exception/">spring Boot 2.x | 自定义异常 统一返回值 全局异常处理</a></h1>
	

		</header>
		<div class="entry">
			
				<blockquote>
<p>本文讲解如何在springboot项目中使用自定义异常，统一返回，全局异常处理 </p>
</blockquote>
<p>新建一个springboot项目，引入web依赖，pom.xml完整依赖如下</p>
<pre><code class="xml">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
        &lt;artifactId&gt;lombok&lt;/artifactId&gt;
        &lt;version&gt;1.16.22&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</code></pre>
<h4 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h4><p>在项目中有的地方，比如入参校验错误，安全校验失败等可能需要主动去抛异常，这时候就需要自己自定义一个异常。</p>
<pre><code class="java">/**
 * @auther: chenmingyu
 * @date: 2018/12/6 14:36
 * @description:
 */
@Data
public class MyException extends RuntimeException{

    private Integer code;

    private String msg;

    public MyException(Integer code, String msg) {
        this.code = code;
        this.msg = msg;
    }

    public MyException(String msg) {
        this.code = ResultTypeEnum.SERVICE_ERROR.getCode();
        this.msg = msg;
    }

    public MyException(ResultTypeEnum resultEnum) {
        this.code = resultEnum.getCode();
        this.msg = resultEnum.getMessage();
    }
}</code></pre>
<p>自定义异常只要新建一个类继承RuntimeException类</p>
<h4 id="统一返回值"><a href="#统一返回值" class="headerlink" title="统一返回值"></a>统一返回值</h4><h5 id="定义统一返回类：Result"><a href="#定义统一返回类：Result" class="headerlink" title="定义统一返回类：Result"></a>定义统一返回类：<code>Result</code></h5><p><code>Result</code> 类构造函数私有化，使用Result 类提供的static方法构造Result 实例返回，再定义一个响应状态的枚举<code>ResultTypeEnum</code>，同一返回状态码等信息。</p>
<pre><code class="java">/**
 * @auther: chenmingyu
 * @date: 2018/10/31 16:47
 * @description:
 */
public class Result&lt;T&gt; implements Serializable {

  private Integer code;
  private String msg;
  private T data;

  private Result() {
  }

  public Result(ResultTypeEnum type) {
    this.code = type.getCode();
    this.msg = type.getMessage();
  }

  public Result(ResultTypeEnum type, T data) {
    this.code = type.getCode();
    this.msg = type.getMessage();
    this.data = data;
  }

  public Result(ResultTypeEnum type, String content, T data) {
    this.code = type.getCode();
    this.msg = content;
    this.data = data;
  }

  public static Result success() {
    return new Result(ResultTypeEnum.SERVICE_SUCCESS);
  }

  public static &lt;T&gt; Result&lt;T&gt; success(T data) {
    return new Result(ResultTypeEnum.SERVICE_SUCCESS, data);
  }

  public static &lt;T&gt; Result&lt;T&gt; error(T data) {
    return new Result(ResultTypeEnum.SERVICE_ERROR, data);
  }

  public static  &lt;T&gt; Result&lt;T&gt; success(String content, T data) {
    return new Result(ResultTypeEnum.SERVICE_SUCCESS, content, data);
  }

  public static Result error() {
    return new Result(ResultTypeEnum.SERVICE_ERROR);
  }

  public static Result error(ResultTypeEnum typeEnum) {
    return new Result(typeEnum);
  }

  public static Result error(ResultTypeEnum typeEnum,String msg) {
    return new Result(typeEnum,msg);
  }

  public String getMsg() {
    return msg;
  }

  public void setMsg(String msg) {
    this.msg = msg;
  }

  public Integer getCode() {
    return code;
  }

  public void setCode(Integer code) {
    this.code = code;
  }

  public T getData() {
    return data;
  }

  public void setData(T data) {
    this.data = data;
  }
}</code></pre>
<h5 id="响应状态枚举：ResultTypeEnum"><a href="#响应状态枚举：ResultTypeEnum" class="headerlink" title="响应状态枚举：ResultTypeEnum"></a>响应状态枚举：ResultTypeEnum</h5><pre><code>/**
 * @auther: chenmingyu
 * @date: 2018/10/31 16:47
 * @description:
 */
public enum ResultTypeEnum {

    SERVICE_SUCCESS(200,&quot;成功&quot;),
    PARAM_ERROR(40001,&quot;入参异常&quot;),
    SERVICE_ERROR(500,&quot;服务异常&quot;);

    private Integer code;
    private String message;

    public int getCode() {
        return code;
    }

    public void setCode(int code) {
        this.code = code;
    }

    public String getMessage() {
        return message;
    }

    public void setMessage(String message) {
        this.message = message;
    }

    ResultTypeEnum(int code, String message) {
        this.code = code;
        this.message = message;
    }
}</code></pre><h5 id="怎么使用"><a href="#怎么使用" class="headerlink" title="怎么使用"></a>怎么使用</h5><pre><code class="java">/**
 * @auther: chenmingyu
 * @date: 2018/12/6 14:20
 * @description:
 */
@RestController
public class ExceptionController {

    /**
     * 成功返回值
     */
    @RequestMapping(&quot;/querySuccess&quot;)
    public Result&lt;String&gt; querySuccess(){
        return Result.success(&quot;我是数据&quot;);
    }

    /**
     * 错误返回值
     */
    @RequestMapping(&quot;/queryError&quot;)
    public Result&lt;String&gt; queryError(){
        return Result.error(ResultTypeEnum.SERVICE_ERROR);
    }
}
</code></pre>
<p>调用 <a href="http://localhost:8080/querySuccess" target="_blank" rel="noopener">http://localhost:8080/querySuccess</a></p>
<p><img src="/springboot-exception/1.png" alt></p>
<p>调用 <a href="http://localhost:8080/queryError" target="_blank" rel="noopener">http://localhost:8080/queryError</a></p>
<p><img src="/springboot-exception/2.png" alt></p>
<h4 id="全局异常处理"><a href="#全局异常处理" class="headerlink" title="全局异常处理"></a>全局异常处理</h4><p>在spring的项目中使用<code>@ControllerAdvice</code>注解来处理controller层报出的异常信息</p>
<pre><code class="java">//ControllerAdvice 注解源码
@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Component
public @interface ControllerAdvice {
    @AliasFor(&quot;basePackages&quot;)
    String[] value() default {};

    @AliasFor(&quot;value&quot;)
    String[] basePackages() default {};

    Class&lt;?&gt;[] basePackageClasses() default {};

    Class&lt;?&gt;[] assignableTypes() default {};

    Class&lt;? extends Annotation&gt;[] annotations() default {};
}</code></pre>
<h5 id="全局异常处理类"><a href="#全局异常处理类" class="headerlink" title="全局异常处理类"></a>全局异常处理类</h5><p><code>@ExceptionHandler(value = Exception.class)：处理Exception类型的异常</code></p>
<p><code>@ResponseStatus：响应的状态码</code></p>
<pre><code class="java">/**
 * @auther: chenmingyu
 * @date: 2018/12/6 10:57
 * @description:
 */
@ControllerAdvice
public class ExceptionHandle extends ResponseEntityExceptionHandler {

    /**
     * 只捕获 IllegalArgumentException 异常
     * @param request
     * @param e
     * @return
     */
    @ExceptionHandler(value = IllegalArgumentException.class)
    @ResponseBody
    @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)
    private Result illegalArgumentExceptionHandler(HttpServletRequest request, Exception e) {
        System.out.println(&quot;IllegalArgumentException 异常: &quot; + e.getClass().getName());
        return Result.error(ResultTypeEnum.PARAM_ERROR,&quot;请求地址：&quot;+request.getRequestURI());
    }

    /**
     * 只捕获 MyException 异常
     * @param request
     * @param e
     * @return
     */
    @ExceptionHandler(value = MyException.class)
    @ResponseBody
    @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)
    private Result myExceptionHandler(HttpServletRequest request,MyException e) {
        System.out.println(&quot;自定义异常 ：&quot;+ e.getMsg());
        return  Result.error(e.getMsg()+&quot;url:&quot;+request.getRequestURI());
    }

    /**
     * 默认异常捕获，上面两个异常没走的话走我。
     * @param request
     * @param e
     * @return
     */
    @ExceptionHandler
    @ResponseBody
    @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)
    private Result exceptionHandler(HttpServletRequest request,Exception e) {
        System.out.println(&quot;异常 ：&quot;+ e.getClass().getName());
        request.getMethod();
        return Result.error(ResultTypeEnum.SERVICE_ERROR,&quot;不符合上述异常的默认走我这&quot;);
    }
}</code></pre>
<h5 id="处理异常测试"><a href="#处理异常测试" class="headerlink" title="处理异常测试"></a>处理异常测试</h5><pre><code class="java">/**
 * @auther: chenmingyu
 * @date: 2018/12/6 14:20
 * @description:
 */
@RestController
public class ExceptionController {

    /**
     * 抛出运行时异常
     */
    @RequestMapping(&quot;/throwRuntimeException&quot;)
    public void throwRuntimeException(){
        throw new RuntimeException();
    }

    /**
     * 抛出运行时异常
     */
    @RequestMapping(&quot;/throwIllegalArgumentException&quot;)
    public void throwIllegalArgumentException(){
        throw new IllegalArgumentException();
    }

    /**
     * 抛出自定义异常
     */
    @RequestMapping(&quot;/throwMyException&quot;)
    public void throwMyException(){
        throw new MyException(&quot;我是主动抛出来的&quot;);
    }
}</code></pre>
<p>调用<a href="http://localhost:8080/throwIllegalArgumentException" target="_blank" rel="noopener">http://localhost:8080/throwIllegalArgumentException</a></p>
<p><img src="/springboot-exception/3.png" alt></p>
<p>调用<a href="http://localhost:8080/throwMyException" target="_blank" rel="noopener">http://localhost:8080/throwMyException</a></p>
<p><img src="/springboot-exception/4.png" alt></p>
<p>调用<a href="http://localhost:8080/throwRuntimeException" target="_blank" rel="noopener">http://localhost:8080/throwRuntimeException</a></p>
<p><img src="/springboot-exception/5.png" alt></p>

			
		</div>
		<footer class="clearfix">
			
				
				
					<div class="disqus-comment">
						<i class="fa fa-comment"></i><a href="https://chenmingyu.top/springboot-exception/#disqus_thread" class="comment-link"> 评论</a>
					</div>
				
			
			
	<div class="categories">
		<i class="fa fa-folder"></i>
		
			<a href="/categories/java/">java</a>
		
	</div>

			
	<div class="tags">
		<i class="fa fa-tags"></i>
		
			<a href="/tags/springboot/">#springboot</a>
		
			<a href="/tags/exception/">#exception</a>
		
	</div>

		</footer>
	</div>
</article>
	
		
		<article class="post">
	<div class="post-content">
		<header>
			
				<div class="meta">
					<div class="icon">
						
							<i class="fa fa-file"></i>
						
					</div>
					<time datetime="2018-12-05T08:44:39.000Z">2018-12-05</time>
				</div>
			
			
	
		<h1 class="title" data-role="articleTitle"><a href="/springboot-aop/">spring Boot 2.x | 实现 aop</a></h1>
	

		</header>
		<div class="entry">
			
				<h4 id="什么是aop"><a href="#什么是aop" class="headerlink" title="什么是aop"></a>什么是aop</h4><p>aop（Aspect Oriented Programming）面向切面编程，一种可以在运行时在被调用的方法前后动态织入代码的编程方式。</p>
<h5 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h5><ul>
<li>Aspect： 切面，包含一些Pointcut和Advice</li>
<li>Pointcut：切入点，相当于一个条件，只有符合条件的方法才会走Advice</li>
<li>advice：通知，只有符合Pointcut的方法会执行通知，advice分为before，around，after，AfterReturning，AfterThrowing</li>
<li>advice通过以下几种通知来确定在什么时候调用advice<ul>
<li>@before：前置通知，方法执行之前调用advice</li>
<li>@around：环绕通知，方法执行前后都会调用advice</li>
<li>@after：后置通知，方法执行之后调用advice（无论方法执行是否发送异常，总是调用）</li>
<li>@AfterReturning：后置通知，方法执行之后调用advice，可以获取返回值 （无论方法执行是否发送异常，总是调用）</li>
<li>@AfterThrowing：后置通知，方法执行中发生异常后调用，可以获取异常信息（只有发生异常才会）</li>
</ul>
</li>
</ul>
<h4 id="集成aop"><a href="#集成aop" class="headerlink" title="集成aop"></a>集成aop</h4><ul>
<li>新建一个springboot项目</li>
<li>pom.xml中引入aop依赖 </li>
</ul>
<h5 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h5><p>新建项目后，在pom.xml中引入aop依赖 <code>spring-boot-starter-aop</code> ，pom.xml完整依赖如下：</p>
<pre><code class="xml">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
        &lt;artifactId&gt;lombok&lt;/artifactId&gt;
        &lt;version&gt;1.16.22&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</code></pre>
<h5 id="编写切面"><a href="#编写切面" class="headerlink" title="编写切面"></a>编写切面</h5><pre><code class="java">/**
 * @auther: chenmingyu
 * @date: 2018/12/5 17:26
 * @description:
 */
@Aspect
@Component
public class TestAspect {

    /**
     * 切入点
     */
    @Pointcut(&quot;execution(public * com.my.aop.controller.*.*(..))&quot;)
    public void execute(){
    }

    /**
     * 前置通知
     * @param joinPoint
     */
    @Before(value =&quot;execute()&quot;)
    public void Before(JoinPoint joinPoint) {
        System.out.println(&quot;执行方法之前&quot;);
    }

    /**
     * 环绕通知
     * @param proceedingJoinPoint
     * @return
     */
    @Around(value =&quot;execute()&quot;)
    public Object around(ProceedingJoinPoint proceedingJoinPoint) {
        System.out.println(&quot;环绕通知开始&quot;);
        try {
            System.out.println(&quot;执行方法:&quot; + proceedingJoinPoint.getSignature().getName());
            Object object =  proceedingJoinPoint.proceed();
            System.out.println(&quot;环绕通知结束，方法返回:&quot; + object);
            return object;
        } catch (Throwable e) {
            System.out.println(&quot;执行方法异常:&quot; + e.getClass().getName());
            return null;
        }
    }

    /**
     * 后置通知
     * @param joinPoint
     */
    @After(value =&quot;execute()&quot;)
    public void After(JoinPoint joinPoint) {
        System.out.println(&quot;执行方法之后&quot;);
    }

    /**
     * 后置通知，带返回值
     * @param obj
     */
    @AfterReturning(pointcut = &quot;execute()&quot;,returning = &quot;obj&quot;)
    public void AfterReturning(Object obj) {
        System.out.println(&quot;执行方法之后获取返回值：&quot;+obj);
    }

    /**
     * 后置通知，异常时执行
     * @param e
     */
    @AfterThrowing(throwing = &quot;e&quot;,pointcut = &quot;execute()&quot;)
    public void doAfterThrowing(Exception e) {
        System.out.println(&quot;执行方法异常：&quot;+e.getClass().getName());
    }
}</code></pre>
<p>@Aspect    ：声明这个类是一个切面</p>
<p>@Component：将bean交由spring管理</p>
<p>@Pointcut(“execution(public * com.my.aop.controller.<em>.</em>(..))”)：声明切入点</p>
<p>execution(public * com.my.aop.controller.<em>.</em>(..))：条件表达式，之后com.my.aop.controller包下的public声明的方法会走通知</p>
<p>@Before，@Around，@After，@AfterReturning，@AfterThrowing：通知类型</p>
<h5 id="验证Aspect"><a href="#验证Aspect" class="headerlink" title="验证Aspect"></a>验证Aspect</h5><pre><code class="java">/**
 * @auther: chenmingyu
 * @date: 2018/12/5 17:34
 * @description:
 */
@RestController
public class AspectController {

    /**
     * 走切面
     * @return
     */
    @GetMapping(&quot;/test&quot;)
    public String test(){
        return &quot;method return&quot;;
    }

    /**
     * 不走切面
     */
    @GetMapping(&quot;/test1&quot;)
    private void test1(){
    }

    /**
     * 走切面，抛异常
     */
    @GetMapping(&quot;/throws&quot;)
    public void throwsException(){
        throw new RuntimeException();
    }
}</code></pre>
<p>执行 <a href="http://localhost:8080/test1，没有输出" target="_blank" rel="noopener">http://localhost:8080/test1，没有输出</a></p>
<p>执行 <a href="http://localhost:8080/test，输出如下" target="_blank" rel="noopener">http://localhost:8080/test，输出如下</a></p>
<p><img src="/springboot-aop/1.png" alt></p>
<p>执行 <a href="http://localhost:8080/throws，输出如下" target="_blank" rel="noopener">http://localhost:8080/throws，输出如下</a></p>
<p><img src="/springboot-aop/2.png" alt></p>

			
		</div>
		<footer class="clearfix">
			
				
				
					<div class="disqus-comment">
						<i class="fa fa-comment"></i><a href="https://chenmingyu.top/springboot-aop/#disqus_thread" class="comment-link"> 评论</a>
					</div>
				
			
			
	<div class="categories">
		<i class="fa fa-folder"></i>
		
			<a href="/categories/java/">java</a>
		
	</div>

			
	<div class="tags">
		<i class="fa fa-tags"></i>
		
			<a href="/tags/aop/">#aop</a>
		
			<a href="/tags/springboot/">#springboot</a>
		
	</div>

		</footer>
	</div>
</article>
	
		
		<article class="post">
	<div class="post-content">
		<header>
			
				<div class="meta">
					<div class="icon">
						
							<i class="fa fa-file"></i>
						
					</div>
					<time datetime="2018-12-05T02:37:11.000Z">2018-12-05</time>
				</div>
			
			
	
		<h1 class="title" data-role="articleTitle"><a href="/springboot-redis/">spring Boot 2.x | 集成 redis</a></h1>
	

		</header>
		<div class="entry">
			
				<p>spring Boot 项目中加入redis</p>
<h4 id="集成redis"><a href="#集成redis" class="headerlink" title="集成redis"></a>集成redis</h4><ul>
<li>新建springboot项目</li>
<li>引入redis依赖：spring-boot-starter-data-redis</li>
<li>配置文件中配置相关属性</li>
</ul>
<h5 id="pom-xml引入依赖"><a href="#pom-xml引入依赖" class="headerlink" title="pom.xml引入依赖"></a>pom.xml引入依赖</h5><p>新建项目后，在pom.xml中引入redis依赖 <code>spring-boot-starter-data-redis</code> ，pom.xml完整依赖如下：</p>
<pre><code class="xml">&lt;dependencies&gt;
    &lt;!--Redis 依赖--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;!-- web 依赖--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;
        &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt;
        &lt;version&gt;3.1&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</code></pre>
<h5 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h5><pre><code class="yml">spring:
  redis:
    port: 6379
    host: 127.0.0.1</code></pre>
<p>springboot中提供了两个redis操作的api：RedisTemplate，StringRedisTemplate</p>
<h5 id="使用StringRedisTemplate编写一个工具类"><a href="#使用StringRedisTemplate编写一个工具类" class="headerlink" title="使用StringRedisTemplate编写一个工具类"></a>使用StringRedisTemplate编写一个工具类</h5><pre><code class="java">/**
 * @auther: chenmingyu
 * @date: 2018/11/11 12:04
 * @description: redis工具类
 */
@Component(&quot;redisUtils&quot;)
public class RedisUtils {

    @Resource
    private StringRedisTemplate stringRedisTemplate;

    /**
     * 获取key
     * @param key
     * @return
     */
    public String get(String key){
        try {
            if(StringUtils.isBlank(key)){
                return null;
            }
            return stringRedisTemplate.opsForValue().get(key);
        }catch (Exception e){
            System.out.println(String.format(&quot;获取字符串异常！ key ：%s&quot;,key));
            e.printStackTrace();
        }
        return null;
    }

    /**
     * 设置key
     * @param key
     * @param value
     */
    public Boolean set(String key,String value){
        try {
            if(StringUtils.isBlank(key)||StringUtils.isBlank(value)){
                return false;
            }
            stringRedisTemplate.opsForValue().set(key,value);
            return true;
        }catch (Exception e){
            System.out.println(String.format(&quot;设置字符串异常！ key ：%s ,value：%s&quot;,key,value));
            e.printStackTrace();
        }
        return false;
    }
    /**
     * 删除key
     * @param key
     */
    public Boolean delete(String key){
        try {
            if(StringUtils.isBlank(key)){
                return false;
            }
            return stringRedisTemplate.delete(key);
        }catch (Exception e){
            System.out.println(String.format(&quot;删除key异常！ key ：%s &quot;,key));
            e.printStackTrace();
        }
        return false;
    }

    /**
     * 设置缓存，时间单位为秒
     * @param key
     * @param value
     * @param time
     * @return
     */
    public Boolean setEX(String key,String value,Long time){
        try {
            if(StringUtils.isBlank(key)||StringUtils.isBlank(value)){
                return false;
            }
            stringRedisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS);
            return true;
        }catch (Exception e){
            System.out.println(String.format(&quot;设置缓存异常！ key ：%s ,value：%s,times：%s&quot;,key));
            e.printStackTrace();
        }
        return false;
    }

    /**
     * 获取key缓存时间，时间单位为秒
     * @param key
     * @return
     */
    public Long getExpireTime(String key){
        try {
            if(StringUtils.isBlank(key)){
                return null;
            }
            return stringRedisTemplate.getExpire(key,TimeUnit.SECONDS);
        }catch (Exception e){
            System.out.println(String.format(&quot;获取key缓存时间异常！ key ：%s&quot;,key));
            e.printStackTrace();
        }
        return null;
    }
}</code></pre>
<p>StringRedisTemplate继承自RedisTemplate，StringRedisTemplate中的所有数据类型都是字符串类型，比如key，value，list，hash，set里存的元素都是字符串，与RedisTemplate不同的是StringRedisTemplate改变了序列化方式，StringRedisTemplate使用StringRedisSerializer序列化key，value，List，Hash，Set等数据结构中的元素。</p>
<p><img src="/springboot-redis/E:%5Cmy%5Cmyblog%5Csource_posts%5Cspringboot-redis%5C1.png" alt></p>
<h5 id="使用junit测试"><a href="#使用junit测试" class="headerlink" title="使用junit测试"></a>使用junit测试</h5><pre><code class="java">@RunWith(SpringRunner.class)
@SpringBootTest
public class SpringbootRedisApplicationTests {

    @Resource
    private RedisUtils redisUtils;


    @Test
    public void testSet() {
        Boolean flag = redisUtils.set(&quot;mingyu&quot;,&quot;mingyu&quot;);
        System.out.println(&quot;testSet：&quot;+flag);
    }

    @Test
    public void testGet() {
        String value = redisUtils.get(&quot;mingyu&quot;);
        System.out.println(&quot;testGet：&quot;+value);
    }

    @Test
    public void testDelete() {
        Boolean flag = redisUtils.delete(&quot;mingyu&quot;);
        System.out.println(&quot;testDelete：&quot;+flag);
    }

    @Test
    public void testSetEX() {
        Boolean flag = redisUtils.setEX(&quot;mingyu&quot;,&quot;cmy&quot;,1000L);
        System.out.println(&quot;testSetEX：&quot;+flag);
    }

    @Test
    public void testGetExpireTime() {
        Long time = redisUtils.getExpireTime(&quot;mingyu&quot;);
        System.out.println(&quot;testSetEX：&quot;+time);
    }
}</code></pre>

			
		</div>
		<footer class="clearfix">
			
				
				
					<div class="disqus-comment">
						<i class="fa fa-comment"></i><a href="https://chenmingyu.top/springboot-redis/#disqus_thread" class="comment-link"> 评论</a>
					</div>
				
			
			
	<div class="categories">
		<i class="fa fa-folder"></i>
		
			<a href="/categories/java/">java</a>
		
	</div>

			
	<div class="tags">
		<i class="fa fa-tags"></i>
		
			<a href="/tags/java/">#java</a>
		
			<a href="/tags/redis/">#redis</a>
		
	</div>

		</footer>
	</div>
</article>
	
		
		<article class="post">
	<div class="post-content">
		<header>
			
				<div class="meta">
					<div class="icon">
						
							<i class="fa fa-file"></i>
						
					</div>
					<time datetime="2018-12-02T13:30:33.000Z">2018-12-02</time>
				</div>
			
			
	
		<h1 class="title" data-role="articleTitle"><a href="/springboot-swagger/">spring Boot 2.x | swagger2构建api文档</a></h1>
	

		</header>
		<div class="entry">
			
				<blockquote>
<p>本文讲解springboot中如何集成swagger</p>
<p>swagger2是一个可以构建和调试RESTful API文档的组件，利用swagger2的注解可以快速的在项目中构建Api文档，并且提供了测试API的功能</p>
</blockquote>
<h4 id="集成swagger"><a href="#集成swagger" class="headerlink" title="集成swagger"></a>集成swagger</h4><h5 id="引入swagger依赖"><a href="#引入swagger依赖" class="headerlink" title="引入swagger依赖"></a>引入swagger依赖</h5><pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;io.springfox&lt;/groupId&gt;
    &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;
    &lt;version&gt;2.7.0&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;io.springfox&lt;/groupId&gt;
    &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;
    &lt;version&gt;2.7.0&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
<h5 id="配置swagger"><a href="#配置swagger" class="headerlink" title="配置swagger"></a>配置swagger</h5><pre><code class="java">/**
 * @auther: chenmingyu
 * @date: 2018/12/2 21:39
 * @description:
 */
@Configuration
@EnableSwagger2
public class Swagger2Configration {

    /**
     * 创建api文档
     * @return
     */
    @Bean
    public Docket createRestApi() {
        return new Docket(DocumentationType.SWAGGER_2)
                .apiInfo(apiInfo())
                .select()
                .apis(RequestHandlerSelectors.basePackage(&quot;com.my.swagger&quot;))
                .paths(PathSelectors.any())
                .build();
    }

    /**
     * api文档页面展示信息
     * @return
     */
    private ApiInfo apiInfo() {
        return new ApiInfoBuilder()
                .title(&quot;swagger组件&quot;)
                .description(&quot;测试api文档&quot;)
                .contact(new Contact(&quot;mingyu&quot;, &quot;www.chenmingyu.top&quot;, null))
                .version(&quot;1.0&quot;)
                .build();
    }
}</code></pre>
<p><em>@configration 标识这是一个配置类</em></p>
<p><em>@Bean 将docket对象注入到spring容器</em></p>
<p><em>@EnableSwagger2 开启swagger2</em></p>
<p><em>apis 表示swagger需要扫描的包</em></p>
<p><em>PathSelectors.any() 表示路径选择器匹配所有路径</em></p>
<p><em>contact() 作者信息</em></p>
<h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><pre><code class="java">/**
 * @auther: chenmingyu
 * @date: 2018/12/2 21:43
 * @description:
 */
@RestController
@RequestMapping(&quot;/test&quot;)
@Api(tags =&quot;用户信息接口&quot;)
public class UserController {

    @GetMapping(&quot;/user&quot;)
    @ApiOperation(value=&quot;查询所有&quot;, notes=&quot;查询所有用户信息&quot;)
    public List&lt;User&gt; queryUsers(){
        List&lt;User&gt; userList = new ArrayList&lt;&gt;();
        IntStream.range(0, 5).forEach(i-&gt;{
            User user = new User();
            user.setId(i);
            user.setUserName(&quot;cmy&quot;);
            user.setPassWord(&quot;passWord&quot;);
            userList.add(user);
        });
        return userList;
    }
}
@Data
@ApiModel(value=&quot;用户对象&quot;)
class User {

    private Integer id;
    @ApiModelProperty(value=&quot;用户名称&quot;,name=&quot;userName&quot;)
    private String userName;

    @ApiModelProperty(value=&quot;密码&quot;,name=&quot;passWord&quot;)
    private String passWord;
}</code></pre>
<h5 id="启动项目，查看swagger页面"><a href="#启动项目，查看swagger页面" class="headerlink" title="启动项目，查看swagger页面"></a>启动项目，查看swagger页面</h5><p>文档地址 <a href="http://localhost:8080/swagger-ui.html" target="_blank" rel="noopener">http://localhost:8080/swagger-ui.html</a></p>
<p><img src="/springboot-swagger/1.png" alt></p>
<h5 id="重用注释"><a href="#重用注释" class="headerlink" title="重用注释"></a>重用注释</h5><pre><code class="yml">@Api() 用于类；表示标识这个类是swagger的资源 
tags–表示说明 
value–也是说明，可以使用tags替代 

@ApiOperation() 用于方法；表示一个http请求的操作 
value用于方法描述 
notes用于提示内容 

@ApiParam() 用于方法，参数，字段说明；表示对参数的添加元数据（说明或是否必填等） 
name–参数名 
value–参数说明 
required–是否必填

@ApiModel()用于类 ；表示对类进行说明，用于参数用实体类接收 
value–表示对象名 

@ApiModelProperty()用于方法，字段； 表示对model属性的说明或者数据操作更改 
value–字段说明 
name–重写属性名字 
dataType–重写属性类型 
required–是否必填 
example–举例说明 
hidden–隐藏

@ApiImplicitParam() 用于方法 
表示单独的请求参数

@ApiImplicitParams() 用于方法，包含多个 @ApiImplicitParam 
name–参数ming 
value–参数说明 
dataType–数据类型 
paramType–参数类型 
example–举例说明

@ApiIgnore
作用于方法上，使用这个注解swagger将忽略这个接口</code></pre>

			
		</div>
		<footer class="clearfix">
			
				
				
					<div class="disqus-comment">
						<i class="fa fa-comment"></i><a href="https://chenmingyu.top/springboot-swagger/#disqus_thread" class="comment-link"> 评论</a>
					</div>
				
			
			
	<div class="categories">
		<i class="fa fa-folder"></i>
		
			<a href="/categories/java/">java</a>
		
	</div>

			
	<div class="tags">
		<i class="fa fa-tags"></i>
		
			<a href="/tags/springboot/">#springboot</a>
		
			<a href="/tags/swagger2/">#swagger2</a>
		
	</div>

		</footer>
	</div>
</article>
	
		
		<article class="post">
	<div class="post-content">
		<header>
			
				<div class="meta">
					<div class="icon">
						
							<i class="fa fa-file"></i>
						
					</div>
					<time datetime="2018-12-02T11:32:29.000Z">2018-12-02</time>
				</div>
			
			
	
		<h1 class="title" data-role="articleTitle"><a href="/springboot-mybatis-xml/">spring Boot 2.x | mybatis(xml方式)</a></h1>
	

		</header>
		<div class="entry">
			
				<blockquote>
<p>本文讲解如何在springboot中集成mybatis （xml方式）</p>
<p>spring Boot 支持两种方式集成mybatis，一种是使用注解，另一种是使用xml，两种方式各有优劣，注解方式简洁方便，不需要xml，xml方式可以直观的看到sql，方便sql优化</p>
</blockquote>
<h4 id="集成mybatis"><a href="#集成mybatis" class="headerlink" title="集成mybatis:"></a>集成mybatis:</h4><ul>
<li>新建一个springboot项目</li>
<li>pom.xml中引入mybatis和mysql的依赖</li>
<li>配置文件配置数据库链接属性</li>
</ul>
<h5 id="pom-xml引入mybatis，mysql依赖"><a href="#pom-xml引入mybatis，mysql依赖" class="headerlink" title="pom.xml引入mybatis，mysql依赖"></a>pom.xml引入mybatis，mysql依赖</h5><p>pom.xml中的mybatis，mysql依赖可以在创建项目的时候勾选对应的依赖项<br><img src="/springboot-mybatis-xml/1.png" alt></p>
<p>如果在构建项目是没勾选对应的依赖，可以在建完项目后，手动添加依赖，保证pom.xml有mybatis，mysql依赖</p>
<p>pom.xml对应的依赖</p>
<pre><code class="xml">&lt;dependencies&gt;
    &lt;!-- web --&gt;
    &lt;dependency&gt;
       &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
       &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;!-- mybatis --&gt;
    &lt;dependency&gt;
       &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
       &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
       &lt;version&gt;1.3.2&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!-- mysql --&gt;
    &lt;dependency&gt;
       &lt;groupId&gt;mysql&lt;/groupId&gt;
       &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
       &lt;scope&gt;runtime&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;!-- lombok --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
        &lt;artifactId&gt;lombok&lt;/artifactId&gt;
        &lt;optional&gt;true&lt;/optional&gt;
    &lt;/dependency&gt;
    &lt;!-- junit --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
        &lt;scope&gt;test&lt;/scope&gt;
     &lt;/dependency&gt;
&lt;/dependencies&gt;</code></pre>
<h5 id="application-yml-配置数据库属性，mybatis配置"><a href="#application-yml-配置数据库属性，mybatis配置" class="headerlink" title="application.yml 配置数据库属性，mybatis配置"></a>application.yml 配置数据库属性，mybatis配置</h5><p>application.yml 配置如下：</p>
<pre><code class="yml">spring:
  #mysql配置
  datasource:
    driver-class-name: com.mysql.jdbc.Driver
    url: jdbc:mysql://127.0.0.1:3306/wtx?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false
    username: root
    password: root

mybatis:
  #mybatis xml文件文件地址
  mapper-locations: classpath:mapper/*.xml
  #批量扫描别名包地址
  type-aliases-package: com.my.example.domain
</code></pre>
<h5 id="表结构"><a href="#表结构" class="headerlink" title="表结构"></a>表结构</h5><pre><code class="sql">CREATE TABLE `user` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `user_name` varchar(32) DEFAULT NULL,
  `pass_word` varchar(32) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8;</code></pre>
<p>域对象 user</p>
<pre><code class="java">/**
 * @auther: chenmingyu
 * @date: 2018/11/4 13:39
 * @description:
 */
@Data
public class User {

    private Long id;
    private String userName;
    private String password;
}</code></pre>
<h4 id="xml方式集成mybatis"><a href="#xml方式集成mybatis" class="headerlink" title="xml方式集成mybatis"></a>xml方式集成mybatis</h4><ul>
<li>配置文件中配置mybatis的sql的xml文件的路径</li>
<li>入口类上使用注解@MapperScan指定扫描dao层接口</li>
</ul>
<p>SpringBootApplication 入口类</p>
<pre><code class="java">@SpringBootApplication
@MapperScan(&quot;com.my.example.dao&quot;)
public class SpringbootMybatisApplication {

    public static void main(String[] args) {
        SpringApplication.run(SpringbootMybatisApplication.class, args);
    }
}
</code></pre>
<p>dao层接口</p>
<pre><code class="java">/**
 * @auther: chenmingyu
 * @date: 2018/11/4 13:42
 * @description:
 */
public interface UserMapper {

    User findUserByName(@Param(&quot;id&quot;) Long id) throws Exception;
}</code></pre>
<p>xml文件</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;
&lt;mapper namespace=&quot;com.my.example.dao.UserMapper&quot; &gt;
  &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.my.example.domain.User&quot; &gt;
    &lt;id column=&quot;id&quot; property=&quot;id&quot; jdbcType=&quot;BIGINT&quot; /&gt;
    &lt;result column=&quot;user_name&quot; property=&quot;userName&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;pass_word&quot; property=&quot;passWord&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
  &lt;/resultMap&gt;
  &lt;sql id=&quot;Base_Column_List&quot; &gt;
    id, user_name, pass_word
  &lt;/sql&gt;
  &lt;select id=&quot;findUserByName&quot; resultMap=&quot;BaseResultMap&quot; parameterType=&quot;java.lang.Long&quot; &gt;
    select 
    &lt;include refid=&quot;Base_Column_List&quot; /&gt;
    from user
    where id = #{id,jdbcType=BIGINT}
  &lt;/select&gt;
&lt;/mapper&gt;</code></pre>
<h5 id="使用junit测试mapper"><a href="#使用junit测试mapper" class="headerlink" title="使用junit测试mapper"></a>使用junit测试mapper</h5><pre><code class="java">@RunWith(SpringRunner.class)
@SpringBootTest
public class SpringbootMybatisApplicationTests {

    @Resource
    private UserMapper userMapper;

    @Test
    public void testFindByName() throws Exception {
        User user = userMapper.findUserByName(5L);
        System.out.println(&quot;第一条记录：&quot;+user.toString());
    }
}</code></pre>
<h5 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h5><p><img src="/springboot-mybatis-xml/2.png" alt></p>

			
		</div>
		<footer class="clearfix">
			
				
				
					<div class="disqus-comment">
						<i class="fa fa-comment"></i><a href="https://chenmingyu.top/springboot-mybatis-xml/#disqus_thread" class="comment-link"> 评论</a>
					</div>
				
			
			
	<div class="categories">
		<i class="fa fa-folder"></i>
		
			<a href="/categories/java/">java</a>
		
	</div>

			
	<div class="tags">
		<i class="fa fa-tags"></i>
		
			<a href="/tags/springboot/">#springboot</a>
		
			<a href="/tags/mybatis/">#mybatis</a>
		
	</div>

		</footer>
	</div>
</article>
	
		
		<article class="post">
	<div class="post-content">
		<header>
			
				<div class="meta">
					<div class="icon">
						
							<i class="fa fa-file"></i>
						
					</div>
					<time datetime="2018-12-02T11:23:10.000Z">2018-12-02</time>
				</div>
			
			
	
		<h1 class="title" data-role="articleTitle"><a href="/springboot-mybatis-annotation/">spring Boot 2.x | mybatis（注解方式）</a></h1>
	

		</header>
		<div class="entry">
			
				<blockquote>
<p>本文讲解如何在springboot中集成mybatis （注解方式）</p>
<p>spring Boot 支持两种方式集成mybatis，一种是使用注解，另一种是使用xml，两种方式各有优劣，注解方式简洁方便，不需要xml，xml方式可以直观的看到sql，方便sql优化</p>
</blockquote>
<h4 id="集成mybatis步骤"><a href="#集成mybatis步骤" class="headerlink" title="集成mybatis步骤"></a>集成mybatis步骤</h4><ul>
<li>新建一个springboot项目</li>
<li>pom.xml中引入mybatis和mysql的依赖</li>
<li>配置文件配置数据库链接属性</li>
</ul>
<h5 id="pom-xml引入mybatis，mysql依赖"><a href="#pom-xml引入mybatis，mysql依赖" class="headerlink" title="pom.xml引入mybatis，mysql依赖"></a>pom.xml引入mybatis，mysql依赖</h5><p>pom.xml中的mybatis，mysql依赖可以在创建项目的时候勾选对应的依赖项<br><img src="/springboot-mybatis-annotation/1.png" alt></p>
<p>如果在构建项目是没勾选对应的依赖，可以在建完项目后，手动添加依赖，保证pom.xml有mybatis，mysql依赖就行</p>
<p>pom.xml对应的依赖</p>
<pre><code class="xml">&lt;dependencies&gt;
    &lt;!-- web --&gt;
    &lt;dependency&gt;
       &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
       &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;!-- mybatis --&gt;
    &lt;dependency&gt;
       &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
       &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
       &lt;version&gt;1.3.2&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!-- mysql --&gt;
    &lt;dependency&gt;
       &lt;groupId&gt;mysql&lt;/groupId&gt;
       &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
       &lt;scope&gt;runtime&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;!-- lombok --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
        &lt;artifactId&gt;lombok&lt;/artifactId&gt;
        &lt;optional&gt;true&lt;/optional&gt;
    &lt;/dependency&gt;
    &lt;!-- junit --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
        &lt;scope&gt;test&lt;/scope&gt;
     &lt;/dependency&gt;
&lt;/dependencies&gt;</code></pre>
<h5 id="application-yml-配置数据库属性，mybatis配置"><a href="#application-yml-配置数据库属性，mybatis配置" class="headerlink" title="application.yml 配置数据库属性，mybatis配置"></a>application.yml 配置数据库属性，mybatis配置</h5><p>application.yml 配置如下：</p>
<pre><code class="yml">spring:
  #mysql配置
  datasource:
    driver-class-name: com.mysql.jdbc.Driver
    url: jdbc:mysql://127.0.0.1:3306/wtx?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false
    username: root
    password: root
mybatis:
  configuration:
    #字段名与属性名不一致，设置驼峰转换
    map-underscore-to-camel-case: true</code></pre>
<h5 id="表结构"><a href="#表结构" class="headerlink" title="表结构"></a>表结构</h5><pre><code class="sql">CREATE TABLE `user` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `user_name` varchar(32) DEFAULT NULL,
  `pass_word` varchar(32) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8;</code></pre>
<p>对应的域对象 user</p>
<pre><code class="java">/**
 * @auther: chenmingyu
 * @date: 2018/11/4 13:39
 * @description:
 */
@Data
public class User {

    private Long id;
    private String userName;
    private String password;
}</code></pre>
<h4 id="使用注解方式集成mybatis"><a href="#使用注解方式集成mybatis" class="headerlink" title="使用注解方式集成mybatis"></a>使用注解方式集成mybatis</h4><ul>
<li>使用@Mapper注解标记接口</li>
<li>@Insert，@Update，@Delete，@Select注解标记方法，分别对应增删改查</li>
</ul>
<pre><code class="java">/**
 * @auther: chenmingyu
 * @date: 2018/11/4 13:42
 * @description:
 */
@Mapper
public interface UserMapper {

    @Select(&quot;select * from user where id = #{id}&quot;)
    User findUserByName(@Param(&quot;id&quot;) Long id) throws Exception;

    @Insert(&quot;insert into user values (#{id},#{userName},#{passWord})&quot;)
    int insert(User user);

    @Update(&quot;update user set user_name=#{userName},pass_word=#{passWord} where id = #{id}&quot;)
    int updateById(User user);

    @Delete(&quot;delete from user where id=#{id}&quot;)
    int deleteById(@Param(&quot;id&quot;) String id);
}</code></pre>
<h5 id="使用junit测试mapper"><a href="#使用junit测试mapper" class="headerlink" title="使用junit测试mapper"></a>使用junit测试mapper</h5><pre><code class="java">@RunWith(SpringRunner.class)
@SpringBootTest
public class SpringbootMybatisApplicationTests {

    @Resource
    private UserMapper userMapper;

    @Test
    public void testFindByName() throws Exception {
        User user = userMapper.findUserByName(1L);
        System.out.println(&quot;第一条记录：&quot;+user.toString());
    }
}</code></pre>
<h5 id="测试结果："><a href="#测试结果：" class="headerlink" title="测试结果："></a>测试结果：</h5><p><img src="/springboot-mybatis-annotation/2.png" alt></p>

			
		</div>
		<footer class="clearfix">
			
				
				
					<div class="disqus-comment">
						<i class="fa fa-comment"></i><a href="https://chenmingyu.top/springboot-mybatis-annotation/#disqus_thread" class="comment-link"> 评论</a>
					</div>
				
			
			
	<div class="categories">
		<i class="fa fa-folder"></i>
		
			<a href="/categories/java/">java</a>
		
	</div>

			
	<div class="tags">
		<i class="fa fa-tags"></i>
		
			<a href="/tags/springboot/">#springboot</a>
		
			<a href="/tags/mybatis/">#mybatis</a>
		
	</div>

		</footer>
	</div>
</article>
	

	<nav id="pagination">
	
		<a href="/page/6/" class="prev"><i class="fa fa-chevron-left"></i> 上一页</a>
	
	
		<a href="/page/8/" class="next">下一页 <i class="fa fa-chevron-right"></i></a>
	
</nav>

	
<script>
	(function (disqus_shortname) {
		window.addEventListener('DOMContentLoaded', function () {
			var dsq = document.createElement('script');
			dsq.type = 'text/javascript';
			dsq.async = true;
			dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
			document.getElementsByTagName('head')[0].appendChild(dsq);
		}, false);
	}('dnxbf321'));
</script>



		</div>
		
	</div>
</div>

<footer id="footer">
	<div class="center">
		&copy; 2022
		
			明羽
		.
		&nbsp;&nbsp;
		Blog generated by <a href="http://hexo.io" target="_blank" rel="noopener">hexo</a>
	</div>
</footer>

<script src="/bower_components/jquery/dist/jquery.min.js"></script>
<script src="/js/header-animate.js"></script>


	<script src="/js/title-animate.js"></script>


<script src="/bower_components/jquery_lazyload/jquery.lazyload.js"></script>
<script>
	$('img.lazy').lazyload();
</script>

	<script src="/bower_components/fancybox/source/jquery.fancybox.pack.js"></script>
	<script>
		$('.fancybox').fancybox();
	</script>




</body>
</html>