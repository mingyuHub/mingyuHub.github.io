

<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8"/>
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="renderer" content="webkit">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-status-bar-style" content="black">
	<meta name="description" content="但行好事 莫问前程">

	
		
			<link rel="stylesheet" href="/bower_components/fancybox/source/jquery.fancybox.css">
		
		<link rel="stylesheet" href="/bower_components/font-awesome/css/font-awesome.min.css">
		<link rel="stylesheet" href="/css/style.css">
	

	<title>但行好事 莫问前程 - 明羽</title>
<meta name="generator" content="Hexo 4.2.1"></head>
<body>
<header id="header">
	<div class="center">
		<div class="wrap">
			<div id="site">
				<h1>
					<a href="/">但行好事 莫问前程</a>
					
						<a class="github" href="https://github.com/dnxbf321" target="_blank" rel="noopener">
	  					<svg aria-hidden="true" class="octicon octicon-mark-github" height="28" role="img" version="1.1" viewBox="0 0 16 16" width="28"><path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59 0.4 0.07 0.55-0.17 0.55-0.38 0-0.19-0.01-0.82-0.01-1.49-2.01 0.37-2.53-0.49-2.69-0.94-0.09-0.23-0.48-0.94-0.82-1.13-0.28-0.15-0.68-0.52-0.01-0.53 0.63-0.01 1.08 0.58 1.23 0.82 0.72 1.21 1.87 0.87 2.33 0.66 0.07-0.52 0.28-0.87 0.51-1.07-1.78-0.2-3.64-0.89-3.64-3.95 0-0.87 0.31-1.59 0.82-2.15-0.08-0.2-0.36-1.02 0.08-2.12 0 0 0.67-0.21 2.2 0.82 0.64-0.18 1.32-0.27 2-0.27 0.68 0 1.36 0.09 2 0.27 1.53-1.04 2.2-0.82 2.2-0.82 0.44 1.1 0.16 1.92 0.08 2.12 0.51 0.56 0.82 1.27 0.82 2.15 0 3.07-1.87 3.75-3.65 3.95 0.29 0.25 0.54 0.73 0.54 1.48 0 1.07-0.01 1.93-0.01 2.2 0 0.21 0.15 0.46 0.55 0.38C13.71 14.53 16 11.53 16 8 16 3.58 12.42 0 8 0z"></path></svg>
						</a>
					
				</h1>
				
					<h2>
						<a href="/">明羽</a>
					</h2>
				
			</div>
			<nav id="menu">
				<ul>
					
						<li><a href="/">首页</a></li>
					
						<li><a href="/archives/">归档</a></li>
					
				</ul>
			</nav>
		</div>
	</div>
</header>

<div id="content">
	<div class="center">
		<div class="main-col">
			

	
	<article class="post">
	<div class="post-content">
		<header>
			
				<div class="meta">
					<div class="icon">
						
							<i class="fa fa-file"></i>
						
					</div>
					<time datetime="2019-05-10T02:11:03.000Z">2019-05-10</time>
				</div>
			
			
	
		<h1 class="title">Elasticsearch基础概念详解</h1>
	

		</header>
		<div class="entry">
			
				<h2 id="elasticsearch"><a href="#elasticsearch" class="headerlink" title="elasticsearch"></a>elasticsearch</h2><p>​    elasticsearch是一个近实时分布式搜索和分析引擎，它用于全文搜索、结构化搜索、分析以及将这三者混合使用，使用java编写，基于Lucene 实现</p>
<p><strong>优势</strong>：</p>
<ol>
<li><p>分布式的实时文件存储，每个字段都被索引并可被搜索</p>
</li>
<li><p>实时分析的分布式搜索引擎</p>
</li>
<li><p>横向可扩展：支持上百台服务节点的扩展，集群增加机器简单，支持处理PB级数据</p>
</li>
<li><p>分片机制：</p>
<p>允许水平分割扩展数据，允许分片和并行操作从而提高性能和吞吐量</p>
<p>提供高性能：同一个索引可以分多个主分片（<code>primary shard</code>），每个主分片拥有自己的副本分片(<code>replica shard</code>)，每个副本分片都可以提供服务，提升系统搜索请求的吞吐量和性能</p>
<p>提供高可用性：同一个索引可以分多个主分片，每个主分片拥有零个或者多个副本，如果主分片挂了，可以从副本分片中选择一个作为主分片继续提供服务</p>
</li>
<li><p>隐藏复杂实现：Elasticsearch 内部隐藏了分布式系统的复杂性，我们不用去关心它是如何做到高可用，可扩展，高性能的</p>
</li>
<li><p>易用开源：不需要额外配置，就可以运行一个Elasticsearch服务，开源</p>
</li>
</ol>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ol>
<li><p><code>Cluster</code>：集群</p>
<p>一个集群包含多个节点，对外提供服务，每个节点属于哪个集群通过配置文件中的集群名称决定</p>
</li>
<li><p><code>Node</code>：节点</p>
<p>集群中的一个节点，每个节点也有一个名称，默认是随机分配，也可以自己指定，在es集群中通过节点名称进行管理和通信</p>
</li>
<li><p><code>Index</code>：索引</p>
<p>索引是具有相同结构的文档集合，作用相当于mysql中的库</p>
</li>
<li><p><code>Type</code>：类型</p>
<p>一个索引可以对应一个或者多个类型，类型可以当做是索引的逻辑分区，作用相当于mysql中的表</p>
</li>
<li><p><code>Document</code>：文档</p>
<p>存储在es中的一个<code>JSON</code>格式的字符串，每一个文档有一个文档ID，如果没有自己指定ID，系统会自动生成一个ID，文档的index/type/id必须是唯一的，作用相当于mysql中的行</p>
</li>
<li><p><code>field</code>：字段</p>
<p>一个文档会包含多个字段，每个字段都对应一个字段类型，类似于mysql中的列</p>
</li>
<li><p><code>shard</code>：分片</p>
<p>es中分为<code>primary shard</code>主分片和<code>replica shard</code>副本分片</p>
<p>主分片：当存一个文档的时候会先存储在主分片中，然后复制到不同的副本分片中，默认一个索引会有5个主分片，当然可以自己指定分片数量，当分片一旦建立，分片数量不能改变</p>
<p>副本分片：每一个主分片会有零个或者多个副本，副本主要是主分片的复制，通过副本分片可以提供高可用性，当一个主分片挂了，可以从副本分片中选择一个作为主分片，还可以提高性能，所以主分片不能和副本分片部署在相同的节点上</p>
</li>
<li><p><code>replica</code>：复制</p>
<p>复制是为了防止单点问题，可以做到对故障进行转移，保证系统的高可用</p>
</li>
<li><p>映射</p>
<p>描述数据在每个字段内如何存储，是定义存储和索引的文档类型及字段的过程，索引中的每一个文档都有一个类型，每种类型都有它自己的映射，一个映射定义了文档结构内每个字段的数据类型</p>
<p>使用<code>GET /index/_mapping/type</code>获取对应的<code>/index/type</code>的映射信息</p>
</li>
</ol>
<h3 id="可视化界面Kibana"><a href="#可视化界面Kibana" class="headerlink" title="可视化界面Kibana"></a>可视化界面Kibana</h3><p>建议安装Elasticsearch+Kibana，在Kibana的操作界面对es进行操作</p>
<p>Elasticsearch提供了RESTful接口可以对Elasticsearch进行操作</p>
<p><strong>Kibana操作页面</strong></p>
<p>在Kibana的Dev Tools界面可以对es进行操作，在console界面敲命令，点执行，会在右面输出结果</p>
<p><img src="/es-basics/kibana-health.png" alt></p>
<p><strong>验证Elasticsearch是否安装成功</strong></p>
<p><a href="http://localhost:9200/?pretty" target="_blank" rel="noopener">http://localhost:9200/?pretty</a></p>
<pre><code class="json">{
  &quot;name&quot; : &quot;UzOujcc&quot;, //节点名称
  &quot;cluster_name&quot; : &quot;mx&quot;, //集群名称，我自己设置的
  &quot;cluster_uuid&quot; : &quot;d2K1M95DRzG9XOPDOR_DEQ&quot;,
  &quot;version&quot; : {
    &quot;number&quot; : &quot;6.2.4&quot;, //集群版本
    &quot;build_hash&quot; : &quot;ccec39f&quot;,
    &quot;build_date&quot; : &quot;2018-04-12T20:37:28.497551Z&quot;,
    &quot;build_snapshot&quot; : false,
    &quot;lucene_version&quot; : &quot;7.2.1&quot;,
    &quot;minimum_wire_compatibility_version&quot; : &quot;5.6.0&quot;,
    &quot;minimum_index_compatibility_version&quot; : &quot;5.0.0&quot;
  },
  &quot;tagline&quot; : &quot;You Know, for Search&quot;
}</code></pre>
<p>es提供了一套api，叫做cat api，可以查看es中的信息数据</p>
<p><strong>查看集群健康状况</strong></p>
<p>命令：<code>GET /_cat/health?v</code></p>
<p><img src="/es-basics/health.png" alt></p>
<p><code>status</code>代表着集群的健康程度</p>
<ol>
<li><code>green</code>：每个索引的primary shard和replica shard都是active状态的</li>
<li><code>yellow</code>：每个索引的primary shard都是active状态的，但是部分replica shard不是active状态，处于不可用的状态</li>
<li><code>red</code>：不是所有索引的primary shard都是active状态的，部分索引有数据丢失了</li>
</ol>
<h3 id="索引操作"><a href="#索引操作" class="headerlink" title="索引操作"></a>索引操作</h3><h4 id="查看索引信息"><a href="#查看索引信息" class="headerlink" title="查看索引信息"></a>查看索引信息</h4><p>命令：<code>GET _cat/indices?v</code></p>
<p><img src="/es-basics/index.png" alt></p>
<p>有五个索引，都是的测试数据</p>
<h4 id="新建索引"><a href="#新建索引" class="headerlink" title="新建索引"></a>新建索引</h4><p>命令：<code>PUT /myindex</code></p>
<pre><code class="json">{
  &quot;acknowledged&quot;: true,
  &quot;shards_acknowledged&quot;: true,
  &quot;index&quot;: &quot;myindex&quot;
}</code></pre>
<h4 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h4><p>命令：<code>DELETE myindex</code></p>
<pre><code class="json">{
  &quot;acknowledged&quot;: true
}</code></pre>
<h3 id="文档操作"><a href="#文档操作" class="headerlink" title="文档操作"></a>文档操作</h3><h4 id="添加文档"><a href="#添加文档" class="headerlink" title="添加文档"></a>添加文档</h4><p>添加文档是向索引中添加一条文档，让其能够搜索，文档格式是json串，如果es中有相同id的文档存在则更新这个文档</p>
<p>当创建文档的时候，如果索引不存在，则会自动创建该索引，而且es默认会对document每个field都建立倒排索引，让其可以被搜索</p>
<p>命令：</p>
<pre><code class="json">PUT /index/type/id 
{ 
    &quot;json数据结构体 &quot;
}</code></pre>
<p>例：</p>
<pre><code class="json">PUT /school/student/1
{
  &quot;name&quot;:&quot;张三&quot;,
  &quot;age&quot;:21,
  &quot;class&quot;:2,
  &quot;gender&quot;:&quot;男&quot;
}</code></pre>
<p>返回：</p>
<pre><code class="json">{
  &quot;_index&quot;: &quot;school&quot;, //索引
  &quot;_type&quot;: &quot;student&quot;, //类型
  &quot;_id&quot;: &quot;1&quot;, //id,如果不指定则会系统生成一个20位的id，文档被分到那个分片上就是根据id的散劣值进行控制
  &quot;_version&quot;: 1, //文档版本号，通过这个进行并发控制
  &quot;result&quot;: &quot;created&quot;, //操作类型
  &quot;_shards&quot;: { //分片信息
    &quot;total&quot;: 2, //文档被创建时在多少个分片进行了操作（包括主分片和副本分片）
    &quot;successful&quot;: 1, //添加成功的索引分片数量
    &quot;failed&quot;: 0 //失败的索引分片数量
  },
  &quot;_seq_no&quot;: 0,
  &quot;_primary_term&quot;: 1
}</code></pre>
<h4 id="修改文档"><a href="#修改文档" class="headerlink" title="修改文档"></a>修改文档</h4><p>方式1：使用put方式更新文档</p>
<pre><code class="json">PUT /school/student/1
{
  &quot;name&quot;:&quot;吕布&quot;,
  &quot;age&quot;:21,
  &quot;class&quot;:2,
  &quot;gender&quot;:&quot;男&quot;
}</code></pre>
<p>返回：</p>
<pre><code class="json">{
  &quot;_index&quot;: &quot;school&quot;,
  &quot;_type&quot;: &quot;student&quot;,
  &quot;_id&quot;: &quot;1&quot;,
  &quot;_version&quot;: 2, //版本号+1
  &quot;result&quot;: &quot;updated&quot;, // 修改
  &quot;_shards&quot;: {
    &quot;total&quot;: 2,
    &quot;successful&quot;: 1,
    &quot;failed&quot;: 0
  },
  &quot;_seq_no&quot;: 1,
  &quot;_primary_term&quot;: 1
}</code></pre>
<p>这种方式替换需要带上所有的field，才能进行信息的修改，操作类似于覆盖</p>
<p>方式2：post更新文档</p>
<pre><code class="json">POST /school/student/1/_update
{
  &quot;doc&quot;: {
    &quot;name&quot;:&quot;吕布1&quot;
  }
}</code></pre>
<p>使用post更新文档，可以只更新部分字段</p>
<h4 id="查询文档"><a href="#查询文档" class="headerlink" title="查询文档"></a>查询文档</h4><p>查询单条文档</p>
<p>命令：<code>GET /school/student/1</code></p>
<p>返回：</p>
<pre><code class="json">{
  &quot;_index&quot;: &quot;school&quot;,
  &quot;_type&quot;: &quot;student&quot;,
  &quot;_id&quot;: &quot;1&quot;,
  &quot;_version&quot;: 3,
  &quot;found&quot;: true,
  &quot;_source&quot;: {
    &quot;name&quot;: &quot;吕布1&quot;,
    &quot;age&quot;: 21,
    &quot;class&quot;: 2,
    &quot;gender&quot;: &quot;男&quot;
  }
}</code></pre>
<h4 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h4><p>命令：<code>DELETE school/student/1</code></p>
<p>返回：</p>
<pre><code class="json">{
  &quot;_index&quot;: &quot;school&quot;,
  &quot;_type&quot;: &quot;student&quot;,
  &quot;_id&quot;: &quot;1&quot;,
  &quot;_version&quot;: 4,
  &quot;result&quot;: &quot;deleted&quot;, //删除
  &quot;_shards&quot;: {
    &quot;total&quot;: 2,
    &quot;successful&quot;: 1,
    &quot;failed&quot;: 0
  },
  &quot;_seq_no&quot;: 3,
  &quot;_primary_term&quot;: 1
}</code></pre>
<p>这时在查询就会显示<code>&quot;found&quot;: false</code></p>
<h3 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h3><p>es中的映射(<code>mapping</code>)用来描述数据在每个字段内如何存储，是定义存储和索引的文档类型及字段的过程，索引中的每一个文档都有一个类型，每种类型都有它自己的映射，一个映射定义了文档结构内每个字段的数据类型，作用相当于<code>mysql</code>中的<code>DDL</code>语句</p>
<h4 id="查询索引类型的映射"><a href="#查询索引类型的映射" class="headerlink" title="查询索引类型的映射"></a>查询索引类型的映射</h4><p><code>GET /ad/_mapping/phone</code></p>
<pre><code class="json">{
  &quot;school&quot;: {
    &quot;mappings&quot;: {
      &quot;student&quot;: {
        &quot;properties&quot;: {
          &quot;age&quot;: {
            &quot;type&quot;: &quot;long&quot;
          },
          &quot;class&quot;: {
            &quot;type&quot;: &quot;long&quot;
          },
          &quot;gender&quot;: {
            &quot;type&quot;: &quot;text&quot;,
            &quot;fields&quot;: {
              &quot;keyword&quot;: {
                &quot;type&quot;: &quot;keyword&quot;,
                &quot;ignore_above&quot;: 256
              }
            }
          },
          &quot;name&quot;: {
            &quot;type&quot;: &quot;text&quot;,
            &quot;fields&quot;: {
              &quot;keyword&quot;: {
                &quot;type&quot;: &quot;keyword&quot;,
                &quot;ignore_above&quot;: 256
              }
            }
          }
        }
      }
    }
  }
}</code></pre>
<h4 id="动态映射"><a href="#动态映射" class="headerlink" title="动态映射"></a>动态映射</h4><p>动态映射不需要事先定义映射，文档在写入es的时候，会根据文档字段自动识别类型</p>
<p>映射规则：</p>
<table>
<thead>
<tr>
<th align="center">Json 数据类型</th>
<th align="center">es 数据类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">null</td>
<td align="center">没有字段添加</td>
</tr>
<tr>
<td align="center">true，false</td>
<td align="center">boolean</td>
</tr>
<tr>
<td align="center">Integer</td>
<td align="center">long</td>
</tr>
<tr>
<td align="center">object</td>
<td align="center">object</td>
</tr>
<tr>
<td align="center">array</td>
<td align="center">依赖于数组中首个非空值</td>
</tr>
<tr>
<td align="center">string</td>
<td align="center">text和keyword</td>
</tr>
<tr>
<td align="center">日期</td>
<td align="center">date或text</td>
</tr>
</tbody></table>
<h4 id="静态映射"><a href="#静态映射" class="headerlink" title="静态映射"></a>静态映射</h4><p>静态映射需要事先定义好映射，包含文档的各个字段及其类型</p>
<pre><code class="json">PUT books
{
  &quot;mappings&quot;: {
    &quot;book&quot;:{
      &quot;properties&quot;: {
        &quot;id&quot;:{&quot;type&quot;: &quot;long&quot;},
        &quot;bookName&quot;:{&quot;type&quot;: &quot;text&quot;},
        &quot;ad&quot;:{&quot;type&quot;: &quot;text&quot;}
      }
    }
  }
}</code></pre>
<p>Elasticsearch 中的数据可以概括的分为两类：精确值和全文</p>
<ol>
<li>精确值：精确值是确定的值，比如用户ID，字符串也可以表示精确值，例如用户名或邮箱地址。对于精确值来讲，<code>Foo</code> 和 <code>foo</code> 是不同的，精确值的查询简单，要么匹配查询，要么不匹配</li>
<li>全文：全文是指文本数据（通常以人类容易识别的语言书写），例如一个推文的内容或一封邮件的内容，全文的查询较为复杂，他需要的是匹配查询的程度有多大</li>
</ol>
<p>在es中使用 倒排索引来进行快速的全文搜索。一个倒排索引由文档中所有不重复词的列表构成，对于其中每个词，有一个包含它的文档列表，<strong>倒排索引</strong>具体内容请戳：<a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/inverted-index.html" target="_blank" rel="noopener">https://www.elastic.co/guide/cn/elasticsearch/guide/current/inverted-index.html</a></p>
<p>es中的字符串类型分为<code>keyword</code>和<code>text</code> </p>
<ol>
<li><code>keyword</code>：用于索引结构化内容的字段，例如电子邮件地址，主机名，状态代码，邮政编码或标签。它们通常用于过滤，排序，和聚合。keyword字段只能按其确切值进行搜索。如果您需要索引电子邮件正文或产品说明等全文内容，则可能应该使用text字段</li>
<li><code>text</code>：用于索引全文值的字段，例如电子邮件正文或产品说明。这些字段是analyzed，它们通过分词器传递 ，以在被索引之前将字符串转换为单个术语的列表。分析过程允许Elasticsearch搜索单个单词中 每个完整的文本字段。文本字段不用于排序，很少用于聚合</li>
</ol>
<p>有时候一个字段同时拥有全文类型（text）和关键字类型（keyword）是有用的：一个用于全文搜索，另一个用于聚合和排序。这可以通过多字段类型来实现（动态映射是字符串的默认映射类型）</p>
<p><strong>参考：</strong> Elasticsearch: 权威指南（版本较老，可以看新的）<a href="https://www.elastic.co/guide/cn/elasticsearch/guide/cn/index.html" target="_blank" rel="noopener">https://www.elastic.co/guide/cn/elasticsearch/guide/cn/index.html</a></p>

			
		</div>
		<footer class="clearfix">
			
			
	<div class="categories">
		<i class="fa fa-folder"></i>
		
			<a href="/categories/elasticsearch/">elasticsearch</a>
		
	</div>

			
	<div class="tags">
		<i class="fa fa-tags"></i>
		
			<a href="/tags/elasticsearch/">#elasticsearch</a>
		
	</div>

		</footer>
	</div>
</article>

	
<section id="comment">
	<div id="disqus_thread"></div>
</section>
<script>
	(function (disqus_shortname) {
		window.addEventListener('DOMContentLoaded', function () {
			var dsq = document.createElement('script');
			dsq.type = 'text/javascript';
			dsq.async = true;
			dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
			document.getElementsByTagName('head')[0].appendChild(dsq);
		}, false);
	}('dnxbf321'));
</script>



		</div>
		

	
	<a href="https://chenmingyu.top/springboot/" id="postPrev" class="icon fa fa-chevron-left"></a>


	<a href="https://chenmingyu.top/redis-lock/" id="postNext" class="icon fa fa-chevron-right"></a>



	</div>
</div>

<footer id="footer">
	<div class="center">
		&copy; 2022
		
			明羽
		.
		&nbsp;&nbsp;
		Blog generated by <a href="http://hexo.io" target="_blank" rel="noopener">hexo</a>
	</div>
</footer>

<script src="/bower_components/jquery/dist/jquery.min.js"></script>
<script src="/js/header-animate.js"></script>



<script src="/bower_components/jquery_lazyload/jquery.lazyload.js"></script>
<script>
	$('img.lazy').lazyload();
</script>

	<script src="/bower_components/fancybox/source/jquery.fancybox.pack.js"></script>
	<script>
		$('.fancybox').fancybox();
	</script>




</body>
</html>