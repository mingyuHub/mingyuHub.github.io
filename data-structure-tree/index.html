

<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8"/>
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="renderer" content="webkit">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-status-bar-style" content="black">
	<meta name="description" content="但行好事 莫问前程">

	
		
			<link rel="stylesheet" href="/bower_components/fancybox/source/jquery.fancybox.css">
		
		<link rel="stylesheet" href="/bower_components/font-awesome/css/font-awesome.min.css">
		<link rel="stylesheet" href="/css/style.css">
	

	<title>但行好事 莫问前程 - 明羽</title>
<meta name="generator" content="Hexo 4.2.1"></head>
<body>
<header id="header">
	<div class="center">
		<div class="wrap">
			<div id="site">
				<h1>
					<a href="/">但行好事 莫问前程</a>
					
						<a class="github" href="https://github.com/dnxbf321" target="_blank" rel="noopener">
	  					<svg aria-hidden="true" class="octicon octicon-mark-github" height="28" role="img" version="1.1" viewBox="0 0 16 16" width="28"><path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59 0.4 0.07 0.55-0.17 0.55-0.38 0-0.19-0.01-0.82-0.01-1.49-2.01 0.37-2.53-0.49-2.69-0.94-0.09-0.23-0.48-0.94-0.82-1.13-0.28-0.15-0.68-0.52-0.01-0.53 0.63-0.01 1.08 0.58 1.23 0.82 0.72 1.21 1.87 0.87 2.33 0.66 0.07-0.52 0.28-0.87 0.51-1.07-1.78-0.2-3.64-0.89-3.64-3.95 0-0.87 0.31-1.59 0.82-2.15-0.08-0.2-0.36-1.02 0.08-2.12 0 0 0.67-0.21 2.2 0.82 0.64-0.18 1.32-0.27 2-0.27 0.68 0 1.36 0.09 2 0.27 1.53-1.04 2.2-0.82 2.2-0.82 0.44 1.1 0.16 1.92 0.08 2.12 0.51 0.56 0.82 1.27 0.82 2.15 0 3.07-1.87 3.75-3.65 3.95 0.29 0.25 0.54 0.73 0.54 1.48 0 1.07-0.01 1.93-0.01 2.2 0 0.21 0.15 0.46 0.55 0.38C13.71 14.53 16 11.53 16 8 16 3.58 12.42 0 8 0z"></path></svg>
						</a>
					
				</h1>
				
					<h2>
						<a href="/">明羽</a>
					</h2>
				
			</div>
			<nav id="menu">
				<ul>
					
						<li><a href="/">首页</a></li>
					
						<li><a href="/archives/">归档</a></li>
					
				</ul>
			</nav>
		</div>
	</div>
</header>

<div id="content">
	<div class="center">
		<div class="main-col">
			

	
	<article class="post">
	<div class="post-content">
		<header>
			
				<div class="meta">
					<div class="icon">
						
							<i class="fa fa-file"></i>
						
					</div>
					<time datetime="2019-07-17T08:39:15.000Z">2019-07-17</time>
				</div>
			
			
	
		<h1 class="title">【数据结构】| 众树纷纭</h1>
	

		</header>
		<div class="entry">
			
				<p><strong>数据结构中的树有多种形式，如：二叉树，二叉搜索树，平衡二叉搜索树，红黑树，线段树，trie树，二叉堆等</strong></p>
<p>每一种树结构都是由最基础的树演化而来，每种树的产生都是为了解决某些问题，所以学习的过程也是先学习基础树结构的概念，之后会按照演化顺序进行讲解</p>
<p><strong>树是由有限个结点（假设为n）构成的集合</strong></p>
<p>比如下面这棵树：</p>
<p><img src="/data-structure-tree/tree.png" alt></p>
<p><strong>基础概念：</strong></p>
<p><strong>父节点：</strong>A是B的父节点，A也是C的父节点，B是D的父节点</p>
<p><strong>子节点：</strong>B是A的子节点，C是A的子节点，G是C的子节点</p>
<p><strong>兄弟节点：</strong>B，C拥有共同的父节点A，所以B和C叫兄弟节点</p>
<p><strong>根节点：</strong>没有父节点的节点，叫做根节点，如图中的A就是根节点，一棵树只有一个根节点</p>
<p><strong>叶子节点：</strong>没有子节点的节点，叫做叶子节点，如图中的D，E，F，G节点</p>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>二叉树是众多树型结构中的一种</p>
<p>顾名思义，二叉树中的每个节点最多只能有两个节点，此为二叉，两个节点分别是左子节点和右子节点 ，每个子节点也可是一棵树，也可称为左子树和右子树</p>
<p><img src="/data-structure-tree/%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt></p>
<p>上图中的三棵树都属二叉树，而二叉树中又有两种比较特殊的树：满二叉树和完全二叉树</p>
<p><strong>满二叉树：</strong></p>
<p>​    在一棵二叉树中，如果每个结点都存在左子节点和右子节点，并且所有的叶子节点都在同一层中，这种二叉树叫满二叉树，如上图中的<strong>树1</strong></p>
<p><strong>完全二叉树：</strong></p>
<p>​    在一棵二叉树中，如果叶子节点都在最底下两层，最后一层叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大，这种二叉树叫做完全二叉树，如上图中的<strong>树2</strong></p>
<p><em>满二叉树也是一种特殊的完全二叉树</em></p>
<h4 id="二叉树的存储"><a href="#二叉树的存储" class="headerlink" title="二叉树的存储"></a>二叉树的存储</h4><p>在了解了二叉树的概念之后，我们思考一下该使用何种数据结构如何进行二叉树的存储？</p>
<h5 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h5><p>使用数组存储二叉树节点</p>
<p>以一颗完全二叉树为例，<strong>如果父节点的下标为<code>i</code>，则父节点的左子节点为<code>2*i</code>，右子节点为`2*i+1</strong>`，所以为了方便计算子节点，我们将数组0位置空置，树中节点从根节点开始从数组下标为1的位置进行顺序插入，这样进行节点计算时较为方便</p>
<p><img src="/data-structure-tree/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8.png" alt></p>
<p>完全二叉树的可以按顺序的填满数组，只浪费数组下标为0的那块内存，那我们接下来看下非完全二叉树的顺序存储</p>
<p><img src="/data-structure-tree/%E9%9D%9E%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8.png" alt></p>
<p>我们根据计算节点的公式，可以算出所有子节点对应数组的下标位置，树5这棵二叉树由于B节点没有左子节点，可以计算出这个缺失的节点下标位置为4，这样下标为4的内存就浪费了，如上图</p>
<p>对于这种内存的浪费，树5其实并不明显，可以想象一下如果一棵二叉树有大量的子节点缺失就会导致浪费大量的内存空间</p>
<p><strong>所以如果二叉树是一颗完全二叉树，我们使用数组进行存储，是最节省内存的一种方式</strong></p>
<h5 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h5><p>那非完全二叉树有没有什么好的存储方式那？</p>
<p>使用链表存储二叉树节点</p>
<p>使用链表存储节点的时候，链表的每个节点包括三个字段：二叉树的节点数据，二叉树节点的左子节点的引用，下图中简称左引用，二叉树节点的右子节点的引用，下图中简称右引用</p>
<p><img src="/data-structure-tree/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8.png" alt></p>
<p>使用链表方式存储比使用数组方式存储需要额外存储二叉树节点的左右子节点的引用，但是对于存储大量缺失子节点的二叉树，无疑是比数组更优的一种方法</p>
<h4 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h4><p>在已经了解了二叉树的存储方式后，我们看一下如何遍历二叉树</p>
<p>常见的遍历方式有四种：前序遍历，中序遍历，后序遍历，层次遍历</p>
<p><img src="/data-structure-tree/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86.png" alt></p>
<h5 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h5><p><strong>对于树中的任意节点来说，先打印这个节点，然后再打印它的左子节点，最后打印它的右子节点</strong> </p>
<p>以树6为例：</p>
<ol>
<li>从根节点出发，首先输出这个节点，输出A</li>
<li>向左到达B，输出B，之后继续向左到达D，输出D，在到达H，输出H</li>
<li>H是叶子节点，所以返回D，但是D已经输出过了，所以访问D的右子节点I，输出I</li>
<li>I是叶子节点，所以继续返回到B，访问B的右子节点E，输出E</li>
<li>依照这种方式进行输出</li>
</ol>
<p>输出结果为：A-&gt;B-&gt;D-&gt;H-&gt;I-&gt;E-&gt;C-&gt;F-&gt;G</p>
<h5 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h5><p><strong>对于树中的任意节点来说，先打印它的左子节点，然后再打印它本身，最后打印它的右子节点</strong> </p>
<p>以树6为例：</p>
<ol>
<li>从根节点出发，先不输出他本身，继续向左访问到B，在向左访问到D，再到H</li>
<li>H没有子节点，因此输出自己，再返回到D，输出D，之后访问D的右子节点I，输出I</li>
<li>之后再返回到D，因为D已经输出，在往上返回，到B，输出B，之后访问B的右子节点E，输出E</li>
<li>依照这种方式进行输出</li>
</ol>
<p>输出结果为：H-&gt;D-&gt;I-&gt;B-&gt;E-&gt;A-&gt;F-&gt;C-&gt;G</p>
<h5 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h5><p><strong>对于树中的任意节点来说，先打印它的左子节点，然后再打印它的右子节点，最后打印这个节点本身</strong> </p>
<p>以树6为例：</p>
<ol>
<li>从根节点出发，首先输出自己，继续向左访问到B，直到叶子节点H</li>
<li>H无子节点，输出H，返回到D，继续访问D的右子节点I，I无子节点，输出I</li>
<li>再次返回到D，此时D的子节点都已输出，所以此时输出D，继续返回到B，访问B的右子节点E</li>
<li>E无子节点，故输出E</li>
<li>依照这种方式进行输出</li>
</ol>
<p>输出结果为：H-&gt;I-&gt;D-&gt;E-&gt;B-&gt;F-&gt;G-&gt;C-&gt;A</p>
<h5 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h5><p><strong>从二叉树的根结点开始，从上至下逐层遍历，在同一层，则按从左至右的顺序对每个结点逐个访问</strong></p>
<p>以树6为例：</p>
<p>输出结果为：A-&gt;B-&gt;C-&gt;D-&gt;E-&gt;F-&gt;G-&gt;H-&gt;I</p>
<h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><p><strong>概念：</strong>在二叉搜索树中，任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，其右子树中的每个节点的值都大于这个节点的值</p>
<p>如下图：</p>
<p><img src="/data-structure-tree/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91.png" alt></p>
<h4 id="查找操作"><a href="#查找操作" class="headerlink" title="查找操作"></a>查找操作</h4><p>因为二叉搜索树中任意一个节点的左子树中的节点都小于这个节点的值，右子树中的节点都大于这个节点的值，查询时从根节点开始，如果查询的值小于根节点的值，就去左子树中查询，如果大于根节点的值，就去右子树中查询</p>
<p><strong>在树7中以查找4为例：</strong></p>
<p><img src="/data-structure-tree/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E6%9F%A5%E8%AF%A2.png" alt></p>
<h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><p>插入操作跟查找操作类似，都是根据二叉查找树的特性进行查询可以插入新节点的位置</p>
<p><strong>在树7中以插入12为例：</strong></p>
<p><img src="/data-structure-tree/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E6%8F%92%E5%85%A5.png" alt></p>
<h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><p>删除节点比较复杂，主要是根据要删除的子节点数量进行不同处理</p>
<p><strong>情况1：删除的节点没有子节点，这种情况直接找到节点删除即可</strong></p>
<p>比如删除节点4：</p>
<p><img src="/data-structure-tree/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%A0%E9%99%A41.png" alt></p>
<p><strong>情况2：删除的节点有一个子节点，删除节点，移动其子节点</strong></p>
<p>比如删除节点3：</p>
<p><img src="/data-structure-tree/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%A0%E9%99%A42.png" alt></p>
<p><strong>情况3：删除的节点有两个子节点，首先需要找到右子树中最小的节点，将当前节点替换为最小节点，然后删除最小节点</strong></p>
<p>比如删除节点5：</p>
<p><img src="/data-structure-tree/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%A0%E9%99%A4%E6%83%85%E5%86%B53.png" alt></p>
<h4 id="退化为链表"><a href="#退化为链表" class="headerlink" title="退化为链表"></a>退化为链表</h4><p>当二叉搜索树是满二叉树或完全二叉树时，其查找，添加，删除的时间复杂度是log(n)，当一颗二叉搜索树极度不平衡时，其操作的时间复杂度退化为O(n)</p>
<p>比如向二叉搜索树中按顺序添加 1,2,3,4 ，其二叉搜索树的结构如下图：</p>
<p><img src="/data-structure-tree/%E6%9E%81%E5%BA%A6%E4%B8%8D%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91.png" alt></p>
<p>这时二叉搜索树退化为链表，即便不是退化为链表这种极端情况，只要有左右两颗子树不平衡的情况在（实际上使用时绝大部分都是不平衡的），其操作的时间复杂度就会退化</p>
<h3 id="平衡二叉搜索树（AVL）"><a href="#平衡二叉搜索树（AVL）" class="headerlink" title="平衡二叉搜索树（AVL）"></a>平衡二叉搜索树（AVL）</h3><p>为了解决将有顺序数据添加到二叉查找树时导致二叉搜索树性能变差的情况出现，就需要二叉搜索树可以自己进行自平衡操作，进而使二叉搜索树达到平衡状态，在进行自平衡操作之前，需要了解下平衡的概念</p>
<h4 id="平衡二叉搜索树的平衡"><a href="#平衡二叉搜索树的平衡" class="headerlink" title="平衡二叉搜索树的平衡"></a>平衡二叉搜索树的平衡</h4><p>对于任意一个节点，左右子树的高度之差的绝对值不超过1，那么这棵二叉搜索树是平衡的</p>
<p><strong>节点高度：</strong>左右子树最高的节点高度+1</p>
<p><strong>平衡因子：</strong>左右子树的高度差的绝对值，所以一个平衡二叉搜索树的任意一个节点的平衡因子不能大于1</p>
<p>在二叉搜索树的基础上，满足平衡条件的二叉树，就是平衡二叉搜索树，如下图：</p>
<p><img src="/data-structure-tree/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt></p>
<p>使用这种方式，我们就可以计算出二叉搜索树是否是平衡的，树8的任意一个节点的平衡因子都在-1,0,1之间，所以树8是平衡二叉搜索树</p>
<h4 id="平衡二叉搜索树的自平衡"><a href="#平衡二叉搜索树的自平衡" class="headerlink" title="平衡二叉搜索树的自平衡"></a>平衡二叉搜索树的自平衡</h4><p>一颗平衡二叉搜索树当添加节点的时候，必须更新其父节点的平衡因子，可分为两种情况：</p>
<ol>
<li>递归更新父节点的平衡因子，直到根节点</li>
<li>当父节点的平衡因子为0时其祖先节点的平衡因子不会发生改变，停止更新</li>
</ol>
<p>根据添加的节点位置可以分为4种情况：</p>
<h5 id="情况1：添加的节点在左子树的左边，简称为LL"><a href="#情况1：添加的节点在左子树的左边，简称为LL" class="headerlink" title="情况1：添加的节点在左子树的左边，简称为LL"></a>情况1：添加的节点在左子树的左边，简称为LL</h5><p><img src="/data-structure-tree/LL.png" alt></p>
<ol>
<li>添加的节点F为D节点的左子节点</li>
<li>递归更新父节点的平衡因子，A节点额平衡因子为2</li>
<li>因此以A节点为根节点的子树需要进行自平衡操作</li>
<li>对A节点进行右旋转操作</li>
</ol>
<p>此时自平衡操作完成，二叉搜索树重新变为平衡二叉搜索树</p>
<h5 id="情况2：添加的节点在右子树的右边，简称为RR"><a href="#情况2：添加的节点在右子树的右边，简称为RR" class="headerlink" title="情况2：添加的节点在右子树的右边，简称为RR"></a>情况2：添加的节点在右子树的右边，简称为RR</h5><p><img src="/data-structure-tree/RR.png" alt></p>
<ol>
<li>添加节点F为E的右子节点</li>
<li>递归更新父节点的平衡因子，A节点额平衡因子为2</li>
<li>因此以A节点为根节点的子树需要进行自平衡操作</li>
<li>对A节点进行左旋转操作</li>
</ol>
<h5 id="情况3：添加的节点在左子树的右边，简称为LR"><a href="#情况3：添加的节点在左子树的右边，简称为LR" class="headerlink" title="情况3：添加的节点在左子树的右边，简称为LR"></a>情况3：添加的节点在左子树的右边，简称为LR</h5><p>首先我们尝试使用LL解决方法，对A节点进行右旋转，不过很明显平衡之后的二叉搜索树肯定不是平衡的，B的平衡因子还是2</p>
<p><img src="/data-structure-tree/LR%E6%8F%92%E5%85%A5.png" alt></p>
<p>所以直接使用右旋转操作是行不通的</p>
<p>针对这种情况，<strong>需要先将LR转为LL，之后就可以进LL的自平衡操作了</strong>，具体流程如下</p>
<p><img src="/data-structure-tree/LR%E6%97%8B%E8%BD%AC.png" alt></p>
<ol>
<li>对B进行左旋转，使LR转化为LL</li>
<li>转化为LL后，使用处理LL的自平衡操作，对A进行右旋转</li>
</ol>
<p><strong>无论添加的节点F是E的左子节点还是右子节点，对以上整个自平衡的操作并无影响</strong></p>
<h5 id="情况4：添加的节点在右子树的左边，简称为RL"><a href="#情况4：添加的节点在右子树的左边，简称为RL" class="headerlink" title="情况4：添加的节点在右子树的左边，简称为RL"></a>情况4：添加的节点在右子树的左边，简称为RL</h5><p>这种情况和LR情况类似，需要先将RL转为RR，之后进行RR的自平衡操作即可</p>
<p><img src="/data-structure-tree/E:%5Cmy%5Cmyblog%5Csource_posts%5Cdata-structure-tree%5CRL%E6%97%8B%E8%BD%AC.png" alt></p>
<ol>
<li>对C进行右旋转，使RL转换为RR</li>
<li>转化为RR之后，使用RR的自平衡操作，对A进行左旋转</li>
</ol>
<h5 id="总结一下自平衡转换的规则"><a href="#总结一下自平衡转换的规则" class="headerlink" title="总结一下自平衡转换的规则"></a>总结一下自平衡转换的规则</h5><p>如果是LL，对不平衡的节点进行右旋转</p>
<p>如果是RR，对不平衡的节点进行左旋转</p>
<p>如果是LR，先左旋，变成LL，在右旋转</p>
<p>如果是RL，先右旋，变成RR，在左旋转</p>
<p><em>L对应右旋转，R对应左旋转</em></p>
<p>本来想一篇把开头写的二叉树，二叉搜索树，平衡二叉搜索树，红黑树，线段树，trie树，二叉堆等都讲明白，但是写到平衡二叉搜索树的时候发现篇幅太长了，所以剩下的树放到下一篇去写</p>
<p>画图不易，欢迎点赞</p>
<p>有问题可以评论，一起讨论</p>

			
		</div>
		<footer class="clearfix">
			
			
	<div class="categories">
		<i class="fa fa-folder"></i>
		
			<a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
		
	</div>

			
	<div class="tags">
		<i class="fa fa-tags"></i>
		
			<a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">#数据结构</a>
		
			<a href="/tags/%E7%AE%97%E6%B3%95/">#算法</a>
		
			<a href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/">#二叉树</a>
		
	</div>

		</footer>
	</div>
</article>

	
<section id="comment">
	<div id="disqus_thread"></div>
</section>
<script>
	(function (disqus_shortname) {
		window.addEventListener('DOMContentLoaded', function () {
			var dsq = document.createElement('script');
			dsq.type = 'text/javascript';
			dsq.async = true;
			dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
			document.getElementsByTagName('head')[0].appendChild(dsq);
		}, false);
	}('dnxbf321'));
</script>



		</div>
		

	
	<a href="https://chenmingyu.top/java-collection/" id="postPrev" class="icon fa fa-chevron-left"></a>


	<a href="https://chenmingyu.top/concurrent-lock/" id="postNext" class="icon fa fa-chevron-right"></a>



	</div>
</div>

<footer id="footer">
	<div class="center">
		&copy; 2022
		
			明羽
		.
		&nbsp;&nbsp;
		Blog generated by <a href="http://hexo.io" target="_blank" rel="noopener">hexo</a>
	</div>
</footer>

<script src="/bower_components/jquery/dist/jquery.min.js"></script>
<script src="/js/header-animate.js"></script>



<script src="/bower_components/jquery_lazyload/jquery.lazyload.js"></script>
<script>
	$('img.lazy').lazyload();
</script>

	<script src="/bower_components/fancybox/source/jquery.fancybox.pack.js"></script>
	<script>
		$('.fancybox').fancybox();
	</script>




</body>
</html>