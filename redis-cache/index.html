

<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8"/>
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="renderer" content="webkit">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-status-bar-style" content="black">
	<meta name="description" content="但行好事 莫问前程">

	
		
			<link rel="stylesheet" href="/bower_components/fancybox/source/jquery.fancybox.css">
		
		<link rel="stylesheet" href="/bower_components/font-awesome/css/font-awesome.min.css">
		<link rel="stylesheet" href="/css/style.css">
	

	<title>但行好事 莫问前程 - 明羽</title>
<meta name="generator" content="Hexo 4.2.1"></head>
<body>
<header id="header">
	<div class="center">
		<div class="wrap">
			<div id="site">
				<h1>
					<a href="/">但行好事 莫问前程</a>
					
						<a class="github" href="https://github.com/dnxbf321" target="_blank" rel="noopener">
	  					<svg aria-hidden="true" class="octicon octicon-mark-github" height="28" role="img" version="1.1" viewBox="0 0 16 16" width="28"><path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59 0.4 0.07 0.55-0.17 0.55-0.38 0-0.19-0.01-0.82-0.01-1.49-2.01 0.37-2.53-0.49-2.69-0.94-0.09-0.23-0.48-0.94-0.82-1.13-0.28-0.15-0.68-0.52-0.01-0.53 0.63-0.01 1.08 0.58 1.23 0.82 0.72 1.21 1.87 0.87 2.33 0.66 0.07-0.52 0.28-0.87 0.51-1.07-1.78-0.2-3.64-0.89-3.64-3.95 0-0.87 0.31-1.59 0.82-2.15-0.08-0.2-0.36-1.02 0.08-2.12 0 0 0.67-0.21 2.2 0.82 0.64-0.18 1.32-0.27 2-0.27 0.68 0 1.36 0.09 2 0.27 1.53-1.04 2.2-0.82 2.2-0.82 0.44 1.1 0.16 1.92 0.08 2.12 0.51 0.56 0.82 1.27 0.82 2.15 0 3.07-1.87 3.75-3.65 3.95 0.29 0.25 0.54 0.73 0.54 1.48 0 1.07-0.01 1.93-0.01 2.2 0 0.21 0.15 0.46 0.55 0.38C13.71 14.53 16 11.53 16 8 16 3.58 12.42 0 8 0z"></path></svg>
						</a>
					
				</h1>
				
					<h2>
						<a href="/">明羽</a>
					</h2>
				
			</div>
			<nav id="menu">
				<ul>
					
						<li><a href="/">首页</a></li>
					
						<li><a href="/archives/">归档</a></li>
					
				</ul>
			</nav>
		</div>
	</div>
</header>

<div id="content">
	<div class="center">
		<div class="main-col">
			

	
	<article class="post">
	<div class="post-content">
		<header>
			
				<div class="meta">
					<div class="icon">
						
							<i class="fa fa-file"></i>
						
					</div>
					<time datetime="2019-04-01T10:19:05.000Z">2019-04-01</time>
				</div>
			
			
	
		<h1 class="title">redis结合自定义注解实现注解缓存</h1>
	

		</header>
		<div class="entry">
			
				<blockquote>
<p>现在的互联网公司大多数都是以<code>redis</code>作为缓存，本文分享如何在工作中更好的去实现缓存</p>
</blockquote>
<h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><p>   在方法上使用注解，实现如果标注了注解的方法会优先走缓存，如果命中缓存则返回缓存中的数据，如果没有命中缓存就穿透到方法中执行方法，然后将方法的返回值存储到缓存中，然后下次就可以在缓存设置的有效时间内从缓存中读取数据了</p>
<h4 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h4><ol>
<li>自定义注解</li>
<li>定义aop切面</li>
</ol>
<h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><ol>
<li>如果方法标注了<code>@CacheProfiler</code>注解则走<code>aop</code></li>
<li>如果获取到<code>CacheProfiler</code>类，并且<code>readFromCache()设置的是true，就去getCacheKey()</code>获取缓存的<code>key</code></li>
<li>根据缓存的<code>key</code>值去<code>redis</code>中查询，如果有就查询缓存，如果没有就执行方法，将方法的返回值作为<code>value</code>存入缓存,并根据<code>CacheProfiler</code>的<code>expire()</code>设置的过期时间给<code>key</code>加上过期时间</li>
</ol>
<h5 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h5><pre><code class="java">/**
 * @Description:
 * @author: chenmingyu
 * @date: 2018/5/17 20:37
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.METHOD})
public @interface CacheProfiler {

    String cacheKey();

    int expire() default 60;

    boolean readFromCache() default true;
}</code></pre>
<p><strong>代码</strong></p>
<p><code>@interface</code>来修饰一个注解</p>
<ol>
<li><code>cacheKey()</code> 缓存<code>key</code>的前缀，缓存key由key前缀+入参组成，详见<code>getCacheKey()</code>方法</li>
<li><code>expire()</code>缓存的过去时间，默认为<code>60</code>秒</li>
<li><code>readFromCache()</code> 是否读取缓存，默认为<code>true</code></li>
</ol>
<h5 id="定义aop切面"><a href="#定义aop切面" class="headerlink" title="定义aop切面"></a>定义aop切面</h5><pre><code class="java">    @Pointcut(&quot;@annotation(org.my.cache.annotation.CacheProfiler)&quot;)
    public void cachePoint() {
    }

    @Around(&quot;cachePoint()&quot;)
    public Object beforeExec(ProceedingJoinPoint joinPoint) {
        Object obj = null;
        try {
            //获取方法
            Method method = this.getMethod(joinPoint);
            CacheProfiler cacheProfiler = (CacheProfiler) method.getAnnotation(CacheProfiler.class);
            //方法上没有注解，直接执行方法然后返回
            if (null == cacheProfiler) {
                return joinPoint.proceed();
            }
            //缓存key
            String cacheKey = this.getCacheKey(joinPoint, cacheProfiler);
            //true：从缓存读
            if (cacheProfiler.readFromCache()) {
                obj = jedis.get(cacheKey);
            } else {
                return joinPoint.proceed();
            }
            if (null == obj) {
                obj = joinPoint.proceed();
            }else{
                return obj;
            }
            if (null != obj) {
                jedis.setex(cacheKey,cacheProfiler.expire(), JSONObject.toJSONString(obj));
            }
            return obj;
        } catch (Throwable throwable) {
            throwable.printStackTrace();
    }
        return obj;
    }</code></pre>
<p><strong>代码</strong></p>
<p><code>@Pointcut</code>定义切入点为<code>@CacheProfiler</code>注解<code>@Around</code>表示使用<code>@CacheProfiler``注解的方法将走环绕通知 getMethod(JoinPoint jp)</code>获取目标方法<code>getCacheKey(ProceedingJoinPoint jp, CacheProfiler cacheProfiler)</code>获取缓存的<code>key</code></p>
<h5 id="获取CacheProfiler的方法"><a href="#获取CacheProfiler的方法" class="headerlink" title="获取CacheProfiler的方法"></a>获取CacheProfiler的方法</h5><pre><code class="java">//获取方法
private Method getMethod(JoinPoint jp) throws Exception {
    MethodSignature msig = (MethodSignature) jp.getSignature();
    Method method = msig.getMethod();
    return method;
}</code></pre>
<h5 id="获取缓存的key的方法"><a href="#获取缓存的key的方法" class="headerlink" title="获取缓存的key的方法"></a>获取缓存的key的方法</h5><pre><code class="java">private String getCacheKey(ProceedingJoinPoint jp, CacheProfiler cacheProfiler) {
        StringBuilder sb = new StringBuilder(cacheProfiler.cacheKey());
        if (jp.getArgs() != null &amp;&amp; jp.getArgs().length != 0) {
            Object[] arr$ = jp.getArgs();
            int len$ = arr$.length;

            for (int i$ = 0; i$ &lt; len$; ++i$) {
                Object obj = arr$[i$];
                if (obj != null) {
                    sb.append(&quot;_&quot;).append(String.valueOf(obj));
                }
            }
            return sb.toString();
        } else {
            return sb.toString();
        }
    }</code></pre>
<p>   通过在方法上使用<code>@CacheProfiler</code>注解实现缓存，通过<code>@CacheProfiler</code>注解的相应参数去实现缓存属性的相关设置</p>
<h5 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h5><pre><code class="java">/**
* @Description:
* @author: chenmingyu
* @date: 2018/5/20 11:18
*/
@RestController
public class CacheController {

   @RequestMapping(&quot;/getUser&quot;)
   @CacheProfiler(cacheKey = &quot;USER_CACHE_KEY&quot;,expire = 3*60,readFromCache = true)
   public List&lt;User&gt; getUser(Integer type){

       List&lt;User&gt; users = new ArrayList&lt;&gt;();
       if(type==1){
           User user = new User(&quot;my&quot;,24,&quot;北京&quot;);
           users.add(user);
       }else if(type==2){
           User user = new User(&quot;小娜&quot;,24,&quot;北京&quot;);
           users.add(user);
       }
       return users;

   }

}</code></pre>
<p>以上就实现了注解缓存</p>
<h4 id="托底缓存的实现"><a href="#托底缓存的实现" class="headerlink" title="托底缓存的实现"></a>托底缓存的实现</h4><p>   托底缓存的实现也很简单，首先说下可能需要托底缓存的场景，就比如一个电商网站，去获取商品列表，结果调用接口的时候出错了，这个时候又不希望网站的页面出现天窗这个时候就需要托底数据了，如果接口出现异常，也会返回托底数据</p>
<h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><ul>
<li>可以给<code>CacheProfiler</code>注解加一个属性是否读取托底缓存 属性为<code>boolean</code></li>
<li>然后在<code>joinPoint.proceed()</code>的时候加上<code>try-cache</code></li>
<li>如果执行方法的时候报异常了，或者返回一些自定义的数据，并且上面那个是否读取托底缓存属性为true，就去缓存中读取托底数据</li>
<li>其中重要的一点就是托底数据什么时候去存，这个可以在每次去存缓存的时候去存一份托底数据，或者定义一些存储策略，托底数据与缓存的数据可以定义为key的前缀不同，其实这个可以存成hash类型的数据，定义一个固定的key为托底数据的key【hash的key】，然后field为托底缓存数据的key</li>
</ul>

			
		</div>
		<footer class="clearfix">
			
			
	<div class="categories">
		<i class="fa fa-folder"></i>
		
			<a href="/categories/nosql/">nosql</a>
		
	</div>

			
	<div class="tags">
		<i class="fa fa-tags"></i>
		
			<a href="/tags/redis/">#redis</a>
		
	</div>

		</footer>
	</div>
</article>

	
<section id="comment">
	<div id="disqus_thread"></div>
</section>
<script>
	(function (disqus_shortname) {
		window.addEventListener('DOMContentLoaded', function () {
			var dsq = document.createElement('script');
			dsq.type = 'text/javascript';
			dsq.async = true;
			dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
			document.getElementsByTagName('head')[0].appendChild(dsq);
		}, false);
	}('dnxbf321'));
</script>



		</div>
		

	
	<a href="https://chenmingyu.top/redis-master-slave/" id="postPrev" class="icon fa fa-chevron-left"></a>


	<a href="https://chenmingyu.top/design-flyweight/" id="postNext" class="icon fa fa-chevron-right"></a>



	</div>
</div>

<footer id="footer">
	<div class="center">
		&copy; 2022
		
			明羽
		.
		&nbsp;&nbsp;
		Blog generated by <a href="http://hexo.io" target="_blank" rel="noopener">hexo</a>
	</div>
</footer>

<script src="/bower_components/jquery/dist/jquery.min.js"></script>
<script src="/js/header-animate.js"></script>



<script src="/bower_components/jquery_lazyload/jquery.lazyload.js"></script>
<script>
	$('img.lazy').lazyload();
</script>

	<script src="/bower_components/fancybox/source/jquery.fancybox.pack.js"></script>
	<script>
		$('.fancybox').fancybox();
	</script>




</body>
</html>